!SESSION 2015-04-11 19:38:41.153 -----------------------------------------------
eclipse.buildId=4.4.2.M20150204-1700
java.version=1.8.0_25
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.egit.ui 2 0 2015-04-11 19:39:02.982
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\David'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.apache.ivyde.eclipse 1 0 2015-04-11 19:39:27.922
!MESSAGE starting IvyDE plugin

!ENTRY org.apache.ivyde.eclipse 1 0 2015-04-11 19:39:27.978
!MESSAGE IvyDE plugin started

!ENTRY org.apache.ivyde.eclipse 2 0 2015-04-11 19:39:27.983
!MESSAGE IvyDE container states of the project guardians-dashboard doesn't exist.

!ENTRY org.apache.ivyde.eclipse 2 0 2015-04-11 19:39:28.024
!MESSAGE IvyDE container states of the project guardians-dashboard doesn't exist.

!ENTRY org.apache.ivyde.eclipse 2 0 2015-04-11 19:39:28.026
!MESSAGE IvyDE container states of the project guardians-dashboard doesn't exist.

!ENTRY org.apache.ivyde.eclipse 4 4 2015-04-11 19:39:37.682
!MESSAGE Some projects fail to be resolved
!SUBENTRY 1 org.apache.ivyde.eclipse 4 0 2015-04-11 19:39:37.682
!MESSAGE Failed to configure Ivy for ivy.xml[nodeploy] in guardians-dashboardError while resolving the ivy instance for ivy.xml[nodeploy] in 'guardians-dashboard':
  The Ivy settings path '${workspace_loc:appEducacionalVaadin/ivysettings.xml}' is incorrect: Variable references non-existent resource : ${workspace_loc:appEducacionalVaadin/ivysettings.xml}
!STACK 0
org.apache.ivyde.eclipse.IvyDEException: Error while resolving the ivy instance for ivy.xml[nodeploy] in 'guardians-dashboard':
  The Ivy settings path '${workspace_loc:appEducacionalVaadin/ivysettings.xml}' is incorrect: Variable references non-existent resource : ${workspace_loc:appEducacionalVaadin/ivysettings.xml}
	at org.apache.ivyde.internal.eclipse.CachedIvy.doGetIvy(CachedIvy.java:134)
	at org.apache.ivyde.internal.eclipse.CachedIvy.getIvy(CachedIvy.java:124)
	at org.apache.ivyde.internal.eclipse.resolve.IvyResolveJob.doRun(IvyResolveJob.java:145)
	at org.apache.ivyde.internal.eclipse.resolve.IvyResolveJob.run(IvyResolveJob.java:85)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: org.eclipse.core.runtime.CoreException: Variable references non-existent resource : ${workspace_loc:appEducacionalVaadin/ivysettings.xml}
	at org.eclipse.debug.internal.core.variables.WorkspaceResolver.resolveValue(WorkspaceResolver.java:66)
	at org.eclipse.core.internal.variables.DynamicVariable.getValue(DynamicVariable.java:56)
	at org.eclipse.core.internal.variables.StringSubstitutionEngine.resolve(StringSubstitutionEngine.java:269)
	at org.eclipse.core.internal.variables.StringSubstitutionEngine.substitute(StringSubstitutionEngine.java:192)
	at org.eclipse.core.internal.variables.StringSubstitutionEngine.performStringSubstitution(StringSubstitutionEngine.java:87)
	at org.eclipse.core.internal.variables.StringVariableManager.performStringSubstitution(StringVariableManager.java:592)
	at org.apache.ivyde.eclipse.cp.ResolvedPath.resolvePath(ResolvedPath.java:90)
	at org.apache.ivyde.eclipse.cp.ResolvedPath.<init>(ResolvedPath.java:49)
	at org.apache.ivyde.eclipse.cp.SettingsSetup.getResolvedIvySettingsPath(SettingsSetup.java:59)
	at org.apache.ivyde.internal.eclipse.cpcontainer.IvyClasspathContainerState.getIvySettingsPath(IvyClasspathContainerState.java:46)
	at org.apache.ivyde.internal.eclipse.CachedIvy.doGetIvy(CachedIvy.java:132)
	... 4 more
!SUBENTRY 1 org.apache.ivyde.eclipse 4 0 2015-04-11 19:39:37.684
!MESSAGE Failed to configure Ivy for ivy.xml[default] in guardians-dashboardError while resolving the ivy instance for ivy.xml[default] in 'guardians-dashboard':
  The Ivy settings path '${workspace_loc:appEducacionalVaadin/ivysettings.xml}' is incorrect: Variable references non-existent resource : ${workspace_loc:appEducacionalVaadin/ivysettings.xml}
!STACK 0
org.apache.ivyde.eclipse.IvyDEException: Error while resolving the ivy instance for ivy.xml[default] in 'guardians-dashboard':
  The Ivy settings path '${workspace_loc:appEducacionalVaadin/ivysettings.xml}' is incorrect: Variable references non-existent resource : ${workspace_loc:appEducacionalVaadin/ivysettings.xml}
	at org.apache.ivyde.internal.eclipse.CachedIvy.doGetIvy(CachedIvy.java:134)
	at org.apache.ivyde.internal.eclipse.CachedIvy.getIvy(CachedIvy.java:124)
	at org.apache.ivyde.internal.eclipse.resolve.IvyResolveJob.doRun(IvyResolveJob.java:145)
	at org.apache.ivyde.internal.eclipse.resolve.IvyResolveJob.run(IvyResolveJob.java:85)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: org.eclipse.core.runtime.CoreException: Variable references non-existent resource : ${workspace_loc:appEducacionalVaadin/ivysettings.xml}
	at org.eclipse.debug.internal.core.variables.WorkspaceResolver.resolveValue(WorkspaceResolver.java:66)
	at org.eclipse.core.internal.variables.DynamicVariable.getValue(DynamicVariable.java:56)
	at org.eclipse.core.internal.variables.StringSubstitutionEngine.resolve(StringSubstitutionEngine.java:269)
	at org.eclipse.core.internal.variables.StringSubstitutionEngine.substitute(StringSubstitutionEngine.java:192)
	at org.eclipse.core.internal.variables.StringSubstitutionEngine.performStringSubstitution(StringSubstitutionEngine.java:87)
	at org.eclipse.core.internal.variables.StringVariableManager.performStringSubstitution(StringVariableManager.java:592)
	at org.apache.ivyde.eclipse.cp.ResolvedPath.resolvePath(ResolvedPath.java:90)
	at org.apache.ivyde.eclipse.cp.ResolvedPath.<init>(ResolvedPath.java:49)
	at org.apache.ivyde.eclipse.cp.SettingsSetup.getResolvedIvySettingsPath(SettingsSetup.java:59)
	at org.apache.ivyde.internal.eclipse.cpcontainer.IvyClasspathContainerState.getIvySettingsPath(IvyClasspathContainerState.java:46)
	at org.apache.ivyde.internal.eclipse.CachedIvy.doGetIvy(CachedIvy.java:132)
	... 4 more
!SUBENTRY 1 org.apache.ivyde.eclipse 4 0 2015-04-11 19:39:37.684
!MESSAGE Failed to configure Ivy for ivy.xml[widgetset-compile] in guardians-dashboardError while resolving the ivy instance for ivy.xml[widgetset-compile] in 'guardians-dashboard':
  The Ivy settings path '${workspace_loc:appEducacionalVaadin/ivysettings.xml}' is incorrect: Variable references non-existent resource : ${workspace_loc:appEducacionalVaadin/ivysettings.xml}
!STACK 0
org.apache.ivyde.eclipse.IvyDEException: Error while resolving the ivy instance for ivy.xml[widgetset-compile] in 'guardians-dashboard':
  The Ivy settings path '${workspace_loc:appEducacionalVaadin/ivysettings.xml}' is incorrect: Variable references non-existent resource : ${workspace_loc:appEducacionalVaadin/ivysettings.xml}
	at org.apache.ivyde.internal.eclipse.CachedIvy.doGetIvy(CachedIvy.java:134)
	at org.apache.ivyde.internal.eclipse.CachedIvy.getIvy(CachedIvy.java:124)
	at org.apache.ivyde.internal.eclipse.resolve.IvyResolveJob.doRun(IvyResolveJob.java:145)
	at org.apache.ivyde.internal.eclipse.resolve.IvyResolveJob.run(IvyResolveJob.java:85)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: org.eclipse.core.runtime.CoreException: Variable references non-existent resource : ${workspace_loc:appEducacionalVaadin/ivysettings.xml}
	at org.eclipse.debug.internal.core.variables.WorkspaceResolver.resolveValue(WorkspaceResolver.java:66)
	at org.eclipse.core.internal.variables.DynamicVariable.getValue(DynamicVariable.java:56)
	at org.eclipse.core.internal.variables.StringSubstitutionEngine.resolve(StringSubstitutionEngine.java:269)
	at org.eclipse.core.internal.variables.StringSubstitutionEngine.substitute(StringSubstitutionEngine.java:192)
	at org.eclipse.core.internal.variables.StringSubstitutionEngine.performStringSubstitution(StringSubstitutionEngine.java:87)
	at org.eclipse.core.internal.variables.StringVariableManager.performStringSubstitution(StringVariableManager.java:592)
	at org.apache.ivyde.eclipse.cp.ResolvedPath.resolvePath(ResolvedPath.java:90)
	at org.apache.ivyde.eclipse.cp.ResolvedPath.<init>(ResolvedPath.java:49)
	at org.apache.ivyde.eclipse.cp.SettingsSetup.getResolvedIvySettingsPath(SettingsSetup.java:59)
	at org.apache.ivyde.internal.eclipse.cpcontainer.IvyClasspathContainerState.getIvySettingsPath(IvyClasspathContainerState.java:46)
	at org.apache.ivyde.internal.eclipse.CachedIvy.doGetIvy(CachedIvy.java:132)
	... 4 more

!ENTRY org.eclipse.m2e.logback.appender 2 0 2015-04-11 19:39:45.454
!MESSAGE The artifact org.apache.commons:commons-io:jar:1.3.2 has been relocated to commons-io:commons-io:jar:1.3.2

!ENTRY org.eclipse.m2e.logback.appender 2 0 2015-04-11 19:39:50.137
!MESSAGE The artifact org.apache.commons:commons-io:jar:1.3.2 has been relocated to commons-io:commons-io:jar:1.3.2

!ENTRY org.eclipse.m2e.logback.appender 2 0 2015-04-11 19:40:16.971
!MESSAGE The artifact org.apache.commons:commons-io:jar:1.3.2 has been relocated to commons-io:commons-io:jar:1.3.2

!ENTRY org.eclipse.e4.ui.workbench 4 2 2015-04-11 19:40:49.755
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jpt.common.ui.internal.jface.AbstractItemStructuredStateProviderManager.getImage(AbstractItemStructuredStateProviderManager.java:158)
	at org.eclipse.jpt.common.ui.internal.navigator.NavigatorLabelProvider.getImage(NavigatorLabelProvider.java:65)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.findImage(NavigatorContentServiceLabelProvider.java:197)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getColumnImage(NavigatorContentServiceLabelProvider.java:105)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getImage(NavigatorContentServiceLabelProvider.java:98)
	at org.eclipse.ui.internal.navigator.resources.workbench.TabbedPropertySheetTitleProvider.getImage(TabbedPropertySheetTitleProvider.java:65)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.refreshTitleBar(TabbedPropertySheetPage.java:850)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.setInput(TabbedPropertySheetPage.java:754)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.selectionChanged(TabbedPropertySheetPage.java:556)
	at org.eclipse.ui.views.properties.PropertySheet.selectionChanged(PropertySheet.java:365)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:218)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handlePostSelectionChanged(SelectionService.java:122)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.access$1(SelectionService.java:112)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService$3.selectionChanged(SelectionService.java:80)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$4.run(SelectionAggregator.java:166)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyPostListeners(SelectionAggregator.java:163)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$8(SelectionAggregator.java:160)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8$1.run(SelectionAggregator.java:272)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:56)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8.changed(SelectionAggregator.java:269)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:338)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:352)
	at org.eclipse.e4.ui.internal.workbench.SelectionServiceImpl.setPostSelection(SelectionServiceImpl.java:36)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart$3.selectionChanged(CompatibilityPart.java:127)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:876)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:873)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1217)
	at org.eclipse.ui.navigator.CommonViewer.handlePostSelect(CommonViewer.java:470)
	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1243)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:265)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:259)
	at org.eclipse.jface.util.OpenStrategy$1$2.run(OpenStrategy.java:440)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2015-04-11 19:40:49.758
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jpt.common.ui.internal.jface.AbstractItemStructuredStateProviderManager.getImage(AbstractItemStructuredStateProviderManager.java:158)
	at org.eclipse.jpt.common.ui.internal.navigator.NavigatorLabelProvider.getImage(NavigatorLabelProvider.java:65)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.findImage(NavigatorContentServiceLabelProvider.java:197)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getColumnImage(NavigatorContentServiceLabelProvider.java:105)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getImage(NavigatorContentServiceLabelProvider.java:98)
	at org.eclipse.ui.internal.navigator.resources.workbench.TabbedPropertySheetTitleProvider.getImage(TabbedPropertySheetTitleProvider.java:65)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.refreshTitleBar(TabbedPropertySheetPage.java:850)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.setInput(TabbedPropertySheetPage.java:754)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.selectionChanged(TabbedPropertySheetPage.java:556)
	at org.eclipse.ui.views.properties.PropertySheet.selectionChanged(PropertySheet.java:365)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:218)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handlePostSelectionChanged(SelectionService.java:122)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.access$1(SelectionService.java:112)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService$3.selectionChanged(SelectionService.java:80)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$4.run(SelectionAggregator.java:166)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyPostListeners(SelectionAggregator.java:163)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$8(SelectionAggregator.java:160)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8$1.run(SelectionAggregator.java:272)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:56)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8.changed(SelectionAggregator.java:269)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:338)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:352)
	at org.eclipse.e4.ui.internal.workbench.SelectionServiceImpl.setPostSelection(SelectionServiceImpl.java:36)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart$3.selectionChanged(CompatibilityPart.java:127)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:876)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:873)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1217)
	at org.eclipse.ui.navigator.CommonViewer.handlePostSelect(CommonViewer.java:470)
	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1243)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:265)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:259)
	at org.eclipse.jface.util.OpenStrategy$1$2.run(OpenStrategy.java:440)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jface 2 0 2015-04-11 19:44:10.296
!MESSAGE Ignored reentrant call while viewer is busy. This is only logged once per viewer instance, but similar calls will still be ignored.
!STACK 0
java.lang.RuntimeException
	at org.eclipse.jface.viewers.ColumnViewer.checkBusy(ColumnViewer.java:759)
	at org.eclipse.jface.viewers.AbstractTreeViewer.add(AbstractTreeViewer.java:147)
	at org.eclipse.ui.navigator.CommonViewer.add(CommonViewer.java:303)
	at org.eclipse.ui.internal.navigator.resources.workbench.ResourceExtensionContentProvider$2.run(ResourceExtensionContentProvider.java:273)
	at org.eclipse.ui.internal.navigator.resources.workbench.ResourceExtensionContentProvider.runUpdates(ResourceExtensionContentProvider.java:312)
	at org.eclipse.ui.internal.navigator.resources.workbench.ResourceExtensionContentProvider.access$1(ResourceExtensionContentProvider.java:310)
	at org.eclipse.ui.internal.navigator.resources.workbench.ResourceExtensionContentProvider$1.run(ResourceExtensionContentProvider.java:134)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.runEventLoop(EventLoopProgressMonitor.java:128)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.isCanceled(EventLoopProgressMonitor.java:102)
	at org.eclipse.core.internal.jobs.ThreadJob.isCanceled(ThreadJob.java:144)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:233)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:197)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:92)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:290)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:118)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2251)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2308)
	at org.eclipse.jst.jee.model.internal.common.AbstractMergedModelProvider.loadModel(AbstractMergedModelProvider.java:249)
	at org.eclipse.jst.jee.model.internal.common.AbstractMergedModelProvider.getMergedModel(AbstractMergedModelProvider.java:219)
	at org.eclipse.jst.jee.model.internal.common.AbstractMergedModelProvider.getModelObject(AbstractMergedModelProvider.java:139)
	at org.eclipse.jst.jee.ui.internal.navigator.JEE5ContentProvider.getCachedContentProvider(JEE5ContentProvider.java:98)
	at org.eclipse.jst.jee.ui.internal.navigator.Web25ContentProvider.getChildren(Web25ContentProvider.java:35)
	at org.eclipse.ui.internal.navigator.extensions.SafeDelegateTreeContentProvider.getChildren(SafeDelegateTreeContentProvider.java:96)
	at org.eclipse.ui.internal.navigator.extensions.SafeDelegateTreeContentProvider.getChildren(SafeDelegateTreeContentProvider.java:275)
	at org.eclipse.ui.internal.navigator.extensions.SafeDelegateTreeContentProvider.getChildren(SafeDelegateTreeContentProvider.java:94)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider$1.run(NavigatorContentServiceContentProvider.java:152)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.internalGetChildren(NavigatorContentServiceContentProvider.java:139)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.getChildren(NavigatorContentServiceContentProvider.java:125)
	at org.eclipse.jface.viewers.AbstractTreeViewer.getRawChildren(AbstractTreeViewer.java:1365)
	at org.eclipse.jface.viewers.TreeViewer.getRawChildren(TreeViewer.java:353)
	at org.eclipse.jface.viewers.StructuredViewer.getFilteredChildren(StructuredViewer.java:905)
	at org.eclipse.jface.viewers.AbstractTreeViewer.getSortedChildren(AbstractTreeViewer.java:617)
	at org.eclipse.jface.viewers.AbstractTreeViewer.updateChildren(AbstractTreeViewer.java:2647)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1918)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:684)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1925)
	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:684)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1893)
	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1850)
	at org.eclipse.ui.navigator.CommonViewer.internalRefresh(CommonViewer.java:561)
	at org.eclipse.jface.viewers.StructuredViewer$8.run(StructuredViewer.java:1528)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1436)
	at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:366)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1397)
	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1525)
	at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:533)
	at org.eclipse.ui.navigator.CommonViewer.refresh(CommonViewer.java:353)
	at org.eclipse.ui.navigator.CommonViewer.refresh(CommonViewer.java:510)
	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1456)
	at org.eclipse.ui.internal.navigator.resources.actions.ResourceMgmtActionProvider$2$1$1.run(ResourceMgmtActionProvider.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.e4.ui.workbench 4 2 2015-04-11 19:56:41.694
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jpt.common.ui.internal.jface.AbstractItemStructuredStateProviderManager.getImage(AbstractItemStructuredStateProviderManager.java:158)
	at org.eclipse.jpt.common.ui.internal.navigator.NavigatorLabelProvider.getImage(NavigatorLabelProvider.java:65)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.findImage(NavigatorContentServiceLabelProvider.java:197)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getColumnImage(NavigatorContentServiceLabelProvider.java:105)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getImage(NavigatorContentServiceLabelProvider.java:98)
	at org.eclipse.ui.internal.navigator.resources.workbench.TabbedPropertySheetTitleProvider.getImage(TabbedPropertySheetTitleProvider.java:65)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.refreshTitleBar(TabbedPropertySheetPage.java:850)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.setInput(TabbedPropertySheetPage.java:754)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.selectionChanged(TabbedPropertySheetPage.java:556)
	at org.eclipse.ui.views.properties.PropertySheet.selectionChanged(PropertySheet.java:365)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:218)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handlePostSelectionChanged(SelectionService.java:122)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.access$1(SelectionService.java:112)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService$3.selectionChanged(SelectionService.java:80)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$4.run(SelectionAggregator.java:166)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyPostListeners(SelectionAggregator.java:163)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$8(SelectionAggregator.java:160)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8$1.run(SelectionAggregator.java:272)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:56)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8.changed(SelectionAggregator.java:269)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:338)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:352)
	at org.eclipse.e4.ui.internal.workbench.SelectionServiceImpl.setPostSelection(SelectionServiceImpl.java:36)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart$3.selectionChanged(CompatibilityPart.java:127)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:876)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:873)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1217)
	at org.eclipse.ui.navigator.CommonViewer.handlePostSelect(CommonViewer.java:470)
	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1243)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:265)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:259)
	at org.eclipse.jface.util.OpenStrategy$1$2.run(OpenStrategy.java:440)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2015-04-11 19:56:41.696
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jpt.common.ui.internal.jface.AbstractItemStructuredStateProviderManager.getImage(AbstractItemStructuredStateProviderManager.java:158)
	at org.eclipse.jpt.common.ui.internal.navigator.NavigatorLabelProvider.getImage(NavigatorLabelProvider.java:65)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.findImage(NavigatorContentServiceLabelProvider.java:197)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getColumnImage(NavigatorContentServiceLabelProvider.java:105)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getImage(NavigatorContentServiceLabelProvider.java:98)
	at org.eclipse.ui.internal.navigator.resources.workbench.TabbedPropertySheetTitleProvider.getImage(TabbedPropertySheetTitleProvider.java:65)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.refreshTitleBar(TabbedPropertySheetPage.java:850)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.setInput(TabbedPropertySheetPage.java:754)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.selectionChanged(TabbedPropertySheetPage.java:556)
	at org.eclipse.ui.views.properties.PropertySheet.selectionChanged(PropertySheet.java:365)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:218)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handlePostSelectionChanged(SelectionService.java:122)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.access$1(SelectionService.java:112)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService$3.selectionChanged(SelectionService.java:80)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$4.run(SelectionAggregator.java:166)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyPostListeners(SelectionAggregator.java:163)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$8(SelectionAggregator.java:160)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8$1.run(SelectionAggregator.java:272)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:56)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8.changed(SelectionAggregator.java:269)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:338)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:352)
	at org.eclipse.e4.ui.internal.workbench.SelectionServiceImpl.setPostSelection(SelectionServiceImpl.java:36)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart$3.selectionChanged(CompatibilityPart.java:127)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:876)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:873)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1217)
	at org.eclipse.ui.navigator.CommonViewer.handlePostSelect(CommonViewer.java:470)
	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1243)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:265)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:259)
	at org.eclipse.jface.util.OpenStrategy$1$2.run(OpenStrategy.java:440)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2015-04-16 18:05:11.919 -----------------------------------------------
eclipse.buildId=4.4.2.M20150204-1700
java.version=1.7.0_75
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.equinox.ds 2 0 2015-04-16 18:06:00.815
!MESSAGE [SCR - WorkThread] Timeout occurred! Thread was blocked on processing [QueuedJob] WorkPerformer: org.eclipse.equinox.internal.ds.SCRManager@1dca8c4a; actionType 1

!ENTRY org.eclipse.equinox.ds 2 0 2015-04-16 18:06:00.815
!MESSAGE [SCR] Enabling components of bundle org.eclipse.ui.trace did not complete in 30000 ms 

!ENTRY org.eclipse.osgi 2 0 2015-04-16 18:08:02.090
!MESSAGE While loading class "org.eclipse.m2e.jdt.internal.MavenClasspathContainerInitializer", thread "Thread[Worker-14,5,main]" timed out waiting (5009ms) for thread "Thread[main,6,main]" to finish starting bundle "org.eclipse.m2e.jdt_1.5.1.20150109-1820 [529]". To avoid deadlock, thread "Thread[Worker-14,5,main]" is proceeding but "org.eclipse.m2e.jdt.internal.MavenClasspathContainerInitializer" may not be fully initialized.
!STACK 0
org.osgi.framework.BundleException: Unable to acquire the state change lock for the module: osgi.identity; osgi.identity="org.eclipse.m2e.jdt"; type="osgi.bundle"; version:Version="1.5.1.20150109-1820"; singleton:="true" [id=529] STARTED [STARTED]
	at org.eclipse.osgi.container.Module.lockStateChange(Module.java:329)
	at org.eclipse.osgi.container.Module.start(Module.java:389)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:320)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:395)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:337)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:568)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:174)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55)
	at org.eclipse.jdt.core.JavaCore.computeClasspathContainerInitializer(JavaCore.java:3294)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainerInitializer(JavaCore.java:3270)
	at org.eclipse.jdt.internal.core.JavaModelManager.initializeContainer(JavaModelManager.java:2883)
	at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1937)
	at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:3247)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2693)
	at org.eclipse.jdt.internal.core.JavaProject.resolveClasspath(JavaProject.java:2857)
	at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath(JavaProject.java:1962)
	at org.eclipse.jdt.internal.core.JavaProject.isOnClasspath(JavaProject.java:2240)
	at org.eclipse.jdt.internal.ui.BuildpathIndicatorLabelDecorator.getOverlay(BuildpathIndicatorLabelDecorator.java:48)
	at org.eclipse.jdt.internal.ui.BuildpathIndicatorLabelDecorator.decorate(BuildpathIndicatorLabelDecorator.java:35)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.ivyde.eclipse 1 0 2015-04-16 18:08:03.903
!MESSAGE starting IvyDE plugin

!ENTRY org.apache.ivyde.eclipse 1 0 2015-04-16 18:08:03.981
!MESSAGE IvyDE plugin started

!ENTRY org.eclipse.m2e.logback.appender 2 0 2015-04-16 18:08:26.796
!MESSAGE The artifact org.apache.commons:commons-io:jar:1.3.2 has been relocated to commons-io:commons-io:jar:1.3.2

!ENTRY org.eclipse.egit.ui 2 0 2015-04-16 18:08:27.234
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\David'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2015-04-16 18:10:22.715
!MESSAGE Could not retrieve superclass
!STACK 0
org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type java.lang.Boolean cannot be resolved. It is indirectly referenced from required .class files
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:152)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:217)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2364)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:4684)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:104)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:182)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.resolve(ParameterizedTypeBinding.java:1029)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:160)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.superclass(BinaryTypeBinding.java:1768)
	at org.eclipse.jdt.core.dom.TypeBinding.getSuperclass(TypeBinding.java:848)
	at org.eclipse.jpt.common.core.internal.utility.jdt.JavaResourceTypeBinding.buildSuperclassNames(JavaResourceTypeBinding.java:170)
	at org.eclipse.jpt.common.core.internal.utility.jdt.JavaResourceTypeBinding.<init>(JavaResourceTypeBinding.java:67)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceAttribute.buildTypeBinding(SourceAttribute.java:116)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceAttribute.initialize(SourceAttribute.java:41)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceField.initialize(SourceField.java:72)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceField.newInstance(SourceField.java:52)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceType.buildField(SourceType.java:525)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceType.initializeFields(SourceType.java:495)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceType.initialize(SourceType.java:131)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceType.newInstance(SourceType.java:93)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceTypeCompilationUnit.buildPrimaryType(SourceTypeCompilationUnit.java:158)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceTypeCompilationUnit.buildPrimaryType(SourceTypeCompilationUnit.java:118)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceTypeCompilationUnit.buildPrimaryType(SourceTypeCompilationUnit.java:63)
	at org.eclipse.jpt.common.core.internal.resource.java.source.SourceTypeCompilationUnit.<init>(SourceTypeCompilationUnit.java:56)
	at org.eclipse.jpt.jpa.core.internal.JavaResourceModelProvider.buildResourceModel(JavaResourceModelProvider.java:48)
	at org.eclipse.jpt.jpa.core.internal.JavaResourceModelProvider.buildResourceModel(JavaResourceModelProvider.java:1)
	at org.eclipse.jpt.jpa.core.internal.GenericJpaPlatform.buildResourceModel(GenericJpaPlatform.java:146)
	at org.eclipse.jpt.jpa.core.internal.GenericJpaPlatform.buildJpaFile(GenericJpaPlatform.java:140)
	at org.eclipse.jpt.jpa.core.internal.GenericJpaPlatform.buildJpaFile(GenericJpaPlatform.java:120)
	at org.eclipse.jpt.jpa.core.internal.AbstractJpaProject.buildJpaFile(AbstractJpaProject.java:624)
	at org.eclipse.jpt.jpa.core.internal.AbstractJpaProject.addJpaFileMaybe_(AbstractJpaProject.java:589)
	at org.eclipse.jpt.jpa.core.internal.AbstractJpaProject$InitialResourceProxyVisitor.visit(AbstractJpaProject.java:349)
	at org.eclipse.core.internal.resources.Resource$1.visitElement(Resource.java:85)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:82)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:86)
	at org.eclipse.core.internal.watson.ElementTreeIterator.iterate(ElementTreeIterator.java:127)
	at org.eclipse.core.internal.resources.Resource.accept(Resource.java:95)
	at org.eclipse.core.internal.resources.Resource.accept(Resource.java:52)
	at org.eclipse.jpt.jpa.core.internal.AbstractJpaProject$InitialResourceProxyVisitor.visitProject(AbstractJpaProject.java:333)
	at org.eclipse.jpt.jpa.core.internal.AbstractJpaProject.<init>(AbstractJpaProject.java:250)
	at org.eclipse.jpt.jpa.eclipselink.core.internal.EclipseLinkJpaProjectImpl.<init>(EclipseLinkJpaProjectImpl.java:26)
	at org.eclipse.jpt.jpa.eclipselink.core.internal.EclipseLinkJpaFactory.buildJpaProject(EclipseLinkJpaFactory.java:62)
	at org.eclipse.jpt.jpa.eclipselink.core.internal.EclipseLinkJpaFactory2_0.buildJpaProject(EclipseLinkJpaFactory2_0.java:72)
	at org.eclipse.jpt.jpa.eclipselink.core.internal.EclipseLinkJpaFactory2_0.buildJpaProject(EclipseLinkJpaFactory2_0.java:1)
	at org.eclipse.jpt.jpa.core.internal.InternalJpaProjectManager.buildJpaProject(InternalJpaProjectManager.java:647)
	at org.eclipse.jpt.jpa.core.internal.InternalJpaProjectManager.buildJpaProject(InternalJpaProjectManager.java:635)
	at org.eclipse.jpt.jpa.core.internal.InternalJpaProjectManager.buildJpaProject(InternalJpaProjectManager.java:628)
	at org.eclipse.jpt.jpa.core.internal.InternalJpaProjectManager.addJpaProject(InternalJpaProjectManager.java:609)
	at org.eclipse.jpt.jpa.core.internal.InternalJpaProjectManager.buildJpaProject_(InternalJpaProjectManager.java:312)
	at org.eclipse.jpt.jpa.core.internal.InternalJpaProjectManager$BuildJpaProjectCommand.execute(InternalJpaProjectManager.java:306)
	at org.eclipse.jpt.common.core.internal.utility.command.CommandJobCommandAdapter.execute(CommandJobCommandAdapter.java:50)
	at org.eclipse.jpt.common.core.internal.utility.command.JobCommandJob.run(JobCommandJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.e4.ui.workbench 4 2 2015-04-17 20:06:49.878
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jpt.common.ui.internal.jface.AbstractItemStructuredStateProviderManager.getImage(AbstractItemStructuredStateProviderManager.java:158)
	at org.eclipse.jpt.common.ui.internal.navigator.NavigatorLabelProvider.getImage(NavigatorLabelProvider.java:65)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.findImage(NavigatorContentServiceLabelProvider.java:197)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getColumnImage(NavigatorContentServiceLabelProvider.java:105)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getImage(NavigatorContentServiceLabelProvider.java:98)
	at org.eclipse.ui.internal.navigator.resources.workbench.TabbedPropertySheetTitleProvider.getImage(TabbedPropertySheetTitleProvider.java:65)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.refreshTitleBar(TabbedPropertySheetPage.java:850)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.setInput(TabbedPropertySheetPage.java:754)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.selectionChanged(TabbedPropertySheetPage.java:556)
	at org.eclipse.ui.views.properties.PropertySheet.selectionChanged(PropertySheet.java:365)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:218)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handlePostSelectionChanged(SelectionService.java:122)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.access$1(SelectionService.java:112)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService$3.selectionChanged(SelectionService.java:80)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$4.run(SelectionAggregator.java:166)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyPostListeners(SelectionAggregator.java:163)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$8(SelectionAggregator.java:160)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8$1.run(SelectionAggregator.java:272)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:56)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8.changed(SelectionAggregator.java:269)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:338)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:352)
	at org.eclipse.e4.ui.internal.workbench.SelectionServiceImpl.setPostSelection(SelectionServiceImpl.java:36)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart$3.selectionChanged(CompatibilityPart.java:127)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:876)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:873)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1217)
	at org.eclipse.ui.navigator.CommonViewer.handlePostSelect(CommonViewer.java:470)
	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1243)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:265)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:259)
	at org.eclipse.jface.util.OpenStrategy$1$2.run(OpenStrategy.java:440)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.msgFilterProc(Display.java:3479)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:256)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4213)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3755)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2015-04-17 20:06:49.906
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jpt.common.ui.internal.jface.AbstractItemStructuredStateProviderManager.getImage(AbstractItemStructuredStateProviderManager.java:158)
	at org.eclipse.jpt.common.ui.internal.navigator.NavigatorLabelProvider.getImage(NavigatorLabelProvider.java:65)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.findImage(NavigatorContentServiceLabelProvider.java:197)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getColumnImage(NavigatorContentServiceLabelProvider.java:105)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceLabelProvider.getImage(NavigatorContentServiceLabelProvider.java:98)
	at org.eclipse.ui.internal.navigator.resources.workbench.TabbedPropertySheetTitleProvider.getImage(TabbedPropertySheetTitleProvider.java:65)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.refreshTitleBar(TabbedPropertySheetPage.java:850)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.setInput(TabbedPropertySheetPage.java:754)
	at org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage.selectionChanged(TabbedPropertySheetPage.java:556)
	at org.eclipse.ui.views.properties.PropertySheet.selectionChanged(PropertySheet.java:365)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:218)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handlePostSelectionChanged(SelectionService.java:122)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.access$1(SelectionService.java:112)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService$3.selectionChanged(SelectionService.java:80)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$4.run(SelectionAggregator.java:166)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyPostListeners(SelectionAggregator.java:163)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$8(SelectionAggregator.java:160)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8$1.run(SelectionAggregator.java:272)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:56)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$8.changed(SelectionAggregator.java:269)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:110)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:338)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:352)
	at org.eclipse.e4.ui.internal.workbench.SelectionServiceImpl.setPostSelection(SelectionServiceImpl.java:36)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart$3.selectionChanged(CompatibilityPart.java:127)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:876)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:873)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1217)
	at org.eclipse.ui.navigator.CommonViewer.handlePostSelect(CommonViewer.java:470)
	at org.eclipse.jface.viewers.StructuredViewer$5.widgetSelected(StructuredViewer.java:1243)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:265)
	at org.eclipse.jface.util.OpenStrategy.access$5(OpenStrategy.java:259)
	at org.eclipse.jface.util.OpenStrategy$1$2.run(OpenStrategy.java:440)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.msgFilterProc(Display.java:3479)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:256)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4213)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3755)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:06:08.047
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->)
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:08.047
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:08.047
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:08.047
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:08.047
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:08.047
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:06:14.241
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return 
		})
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:14.243
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:14.244
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:14.244
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:14.245
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:14.246
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:14.338
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:14.340
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:06:17.813
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return materi
		})
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:17.813
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:17.813
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:17.813
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:17.829
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:17.829
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:17.891
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:17.891
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:18.563
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:18.563
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:06:18.876
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return materia
		})
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:18.876
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:18.891
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:18.891
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:18.891
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:18.891
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:06:25.562
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return materia.getCurso().g
		})
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:25.562
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:25.562
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:25.562
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:25.562
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:25.562
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:25.640
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:25.640
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:06:27.609
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return materia.getCurso().getAlumnos()
		})
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:27.609
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:27.609
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:27.625
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:27.625
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:06:27.625
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:06:27.703
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:06:27.703
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:07:11.725
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			lists.add materia.getCurso().getAlumnos();
		});
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:11.740
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:11.740
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:11.740
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:11.740
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:11.740
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:11.803
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:11.803
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:07:15.337
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			lista.ad materia.getCurso().getAlumnos();
		});
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:15.337
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:15.337
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:15.337
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:15.337
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:15.337
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:15.509
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:15.509
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:07:17.439
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			lista.addAll(arg0) materia.getCurso().getAlumnos();
		});
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:17.441
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:17.441
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:17.442
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:17.443
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:17.444
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:07:20.028
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			lista.addAll(materia.getCurso().getAlumnos();
		});
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:20.028
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:20.028
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:20.028
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:20.028
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:20.028
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:83)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:209)
	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.analyseCode(QualifiedAllocationExpression.java:129)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:175)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:87)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:20.137
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:20.137
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:21.231
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:21.231
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:22.359
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:22.359
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:23.265
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:23.312
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:07:55.514
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return .addAll(materia.getCurso().getAlumnos());
		});
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:55.520
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:55.520
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:55.520
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:55.520
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:55.520
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:55.600
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:55.600
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:07:59.205
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Alumno> lista = Lists.newArrayList();
		profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return materia.getCurso().getAlumnos());
		});
		return lista;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals("Examen")) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals("Trabajo")) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals("Actividad")) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals("EjerciciosEntregados")) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor() {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().size() > 0;
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(final Curso c) {
		List<Alumno> alumnosConTutor = getTodosLosAlumnosProfesorConTutor();
		Iterable<Alumno> filtrado = Iterables.filter(alumnosConTutor,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getCurso().equals(c);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			final PadreMadreOTutor tutor) {
		List<Alumno> alumnosTotales = (List<Alumno>) getTodosLosAlumnosProfesor(profe);
		Iterable<Alumno> filtrado = Iterables.filter(alumnosTotales,
				new Predicate<Alumno>() {
					
					public boolean apply(Alumno p) {
						return p.getPadresMadresOTutores().contains(tutor);
					}
				});
		return Lists.newArrayList(filtrado);
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems() {
		Profesor p = findPrincipal();
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		for (Asignatura a : p.getAsignaturas()) {
			items.addAll(a.getItemsEvaluables());
		}
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:59.207
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:59.208
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:59.208
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:59.209
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:07:59.210
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:07:59.314
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:07:59.315
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:26:44.034
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.persistence.OneToMany;
import javax.validation.constraints.NotNull;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.InstanciaCurso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Collection<Alumno>> alumnos = profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return materia.getCurso().getAlumnos();
		}).collect(Collectors.toList());
		return Lists.newArrayList(Iterables.concat(alumnos));
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals(Examen.class.getSimpleName())) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals(Trabajo.class.getSimpleName())) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals(Actividad.class.getSimpleName())) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals(Ejercicios.class.getSimpleName())) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe) {
		return getTodosLosAlumnosProfesor(profe).stream().filter(alumno ->{
			return alumno.getPadresMadresOTutores().size() > 0;
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(InstanciaCurso c) {
		return c.getAlumnos().stream().filter(alumno->{
			return alumno.getPadresMadresOTutores().size() > 0;
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			PadreMadreOTutor tutor) {
		return getTodosLosAlumnosProfesorConTutor(profe).stream().filter(alumno->{
			return alumno.getPadresMadresOTutores().contains(tutor);
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		getTodosLosAlumnosProfesor(p).stream().map(alumno->)
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:26:44.034
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:44.034
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:44.034
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:26:44.034
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:44.034
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:26:52.278
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.persistence.OneToMany;
import javax.validation.constraints.NotNull;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.InstanciaCurso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Collection<Alumno>> alumnos = profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return materia.getCurso().getAlumnos();
		}).collect(Collectors.toList());
		return Lists.newArrayList(Iterables.concat(alumnos));
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals(Examen.class.getSimpleName())) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals(Trabajo.class.getSimpleName())) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals(Actividad.class.getSimpleName())) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals(Ejercicios.class.getSimpleName())) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe) {
		return getTodosLosAlumnosProfesor(profe).stream().filter(alumno ->{
			return alumno.getPadresMadresOTutores().size() > 0;
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(InstanciaCurso c) {
		return c.getAlumnos().stream().filter(alumno->{
			return alumno.getPadresMadresOTutores().size() > 0;
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			PadreMadreOTutor tutor) {
		return getTodosLosAlumnosProfesorConTutor(profe).stream().filter(alumno->{
			return alumno.getPadresMadresOTutores().contains(tutor);
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		getTodosLosAlumnosProfesor(p).stream().map(alumno->{
			return alumno.get
		})
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:26:52.278
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:52.278
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:52.278
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:26:52.294
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:52.294
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:26:52.387
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:26:52.387
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:26:53.106
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:26:53.106
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:26:53.386
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.persistence.OneToMany;
import javax.validation.constraints.NotNull;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.InstanciaCurso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Collection<Alumno>> alumnos = profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return materia.getCurso().getAlumnos();
		}).collect(Collectors.toList());
		return Lists.newArrayList(Iterables.concat(alumnos));
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals(Examen.class.getSimpleName())) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals(Trabajo.class.getSimpleName())) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals(Actividad.class.getSimpleName())) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals(Ejercicios.class.getSimpleName())) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe) {
		return getTodosLosAlumnosProfesor(profe).stream().filter(alumno ->{
			return alumno.getPadresMadresOTutores().size() > 0;
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(InstanciaCurso c) {
		return c.getAlumnos().stream().filter(alumno->{
			return alumno.getPadresMadresOTutores().size() > 0;
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			PadreMadreOTutor tutor) {
		return getTodosLosAlumnosProfesorConTutor(profe).stream().filter(alumno->{
			return alumno.getPadresMadresOTutores().contains(tutor);
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		getTodosLosAlumnosProfesor(p).stream().map(alumno->{
			return alumno.getI
		})
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:26:53.386
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:53.386
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:53.386
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:26:53.386
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:53.386
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:26:55.370
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:26:55.370
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:26:57.147
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:26:57.147
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.core 4 4 2015-04-17 23:26:58.479
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * ProfesorService.java
 * appEducacional
 * 16/01/2014 11:36:24
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.persistence.OneToMany;
import javax.validation.constraints.NotNull;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.domainservices.Valida;
import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.InstanciaCurso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.Actividad;
import com.app.domain.model.types.itemsevaluables.Ejercicios;
import com.app.domain.model.types.itemsevaluables.Examen;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Trabajo;
import com.app.domain.repositories.ProfesorRepository;
import com.app.infrastructure.security.Authority;
import com.app.infrastructure.security.LoginService;
import com.app.infrastructure.security.UserAccount;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

@Service
@Transactional
/**
 * @author David Romero Alcaide
 *
 */
public class ProfesorService implements Serializable{

	// Repositorios gestionados

	/**
	 * 
	 */
	private static final long serialVersionUID = -928342560252536918L;

	@Autowired
	/**
	 * 
	 */
	private ProfesorRepository profesorRepositorio;

	// Servicios gestionados

	@Autowired
	private ExamenService examenService;
	
	@Autowired
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	private TrabajoService trabajoService;

	@Autowired
	private ActividadService actividadService;

	@Autowired
	private EjerciciosEntregadosService ejerciciosEntregadosService;

	/**
	 * Constructor
	 */
	public ProfesorService() {
		super();

	}

	// Métodos CRUD
	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor create() {
		Profesor p = new Profesor();
		p.setIdentidadConfirmada(false);
		UserAccount account = new UserAccount();
		List<Authority> authorities = Lists.newArrayList();
		Authority auth = new Authority();
		auth.setAuthority(Authority.PROFESOR);
		authorities.add(auth);
		account.setAuthorities(authorities);
		p.setUserAccount(account);

		return p;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Profesor> findAll() {
		List<Profesor> ite;
		ite = profesorRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesorId
	 * @return
	 */
	public Profesor findOne(int profesorId) {
		Assert.isTrue(profesorId > 0);
		return profesorRepositorio.findOne(profesorId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void save(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(Valida.validaDNI(profesor.getDNI()), "pasarLista.error");
		Assert.isTrue(profesor.getApellidos().length() >= 4, "pasarLista.error");
		Assert.isTrue(profesor.getNombre().length() > 2, "pasarLista.error");
		profesorRepositorio.save(profesor);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 */
	public void delete(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId()> 0);
		profesorRepositorio.delete(profesor);
	}

	// Otros métodos de negocio

	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia() {
		Profesor profesor = findPrincipal();
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}
	
	/**
	 * Obtener los cursos en los que imparte docencia un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param profesor
	 * @return
	 */
	public Collection<Curso> getCursosImparteDocencia(Profesor profesor) {
		Assert.notNull(profesor);
		Assert.isTrue(profesor.getId() > 0);
		Assert.isTrue(profesor.isIdentidadConfirmada());
		Collection<Curso> cursos;
		cursos = profesorRepositorio.getCursosDondeImparteClase(profesor
				.getId());
		return cursos;
	}

	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c) {
		Assert.notNull(c);
		Profesor profesor = this.findPrincipal();
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}
	
	/**
	 * Obtiene la asignatura vinculada a un curso y a un profesor
	 * 
	 * @author David Romero Alcaide
	 * @param c
	 * @param p
	 * @return
	 */
	public Asignatura getAsignaturaCursoProfesor(Curso c,Profesor profesor) {
		Assert.notNull(c);
		Assert.notNull(profesor, "pasarLista.profesor");
		Assert.isTrue(profesor.isIdentidadConfirmada());
		return profesorRepositorio.getAsignaturaCursoProfesor(c.getId(),
				profesor.getId());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Profesor findPrincipal() {
		Profesor result;
		UserAccount userAccount;

		userAccount = LoginService.getPrincipal();
		Assert.notNull(userAccount);
		result = findByUserAccount(userAccount);
		Assert.notNull(result);

		return result;
	}

	public Profesor findByUserAccount(UserAccount userAccount) {
		Assert.notNull(userAccount);

		Profesor result;

		result = profesorRepositorio.findByUserAccountId(userAccount.getId());

		return result;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> getTodosLosAlumnosProfesor(Profesor profe) {
		List<Collection<Alumno>> alumnos = profe.getMaterias().stream().filter(materia->{
			return materia.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(materia->{
			return materia.getCurso().getAlumnos();
		}).collect(Collectors.toList());
		return Lists.newArrayList(Iterables.concat(alumnos));
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 */
	public void guardarCalificacion(int idItem, double calificacion,
			String className) {

		if (className.equals(Examen.class.getSimpleName())) {
			Examen exam = examenService.findOne(idItem);
			exam.setCalificacion(calificacion);
			examenService.save(exam);
		} else if (className.equals(Trabajo.class.getSimpleName())) {
			Trabajo trabajo = trabajoService.findOne(idItem);
			trabajo.setCalificacion(calificacion);
			trabajoService.save(trabajo);
		} else if (className.equals(Actividad.class.getSimpleName())) {
			Actividad acti = actividadService.findOne(idItem);
			acti.setCalificacion(calificacion);
			actividadService.save(acti);
		} else if (className.equals(Ejercicios.class.getSimpleName())) {
			Ejercicios ejer = (Ejercicios) ejerciciosEntregadosService
					.findOne(idItem);
			ejer.setCalificacion(calificacion);
			ejerciciosEntregadosService.save(ejer);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe) {
		return getTodosLosAlumnosProfesor(profe).stream().filter(alumno ->{
			return alumno.getPadresMadresOTutores().size() > 0;
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @param c
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutorEnCurso(InstanciaCurso c) {
		return c.getAlumnos().stream().filter(alumno->{
			return alumno.getPadresMadresOTutores().size() > 0;
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public List<Alumno> getTodosLosAlumnosProfesorConTutor(Profesor profe,
			PadreMadreOTutor tutor) {
		return getTodosLosAlumnosProfesorConTutor(profe).stream().filter(alumno->{
			return alumno.getPadresMadresOTutores().contains(tutor);
		}).collect(Collectors.toList());
	}

	/**
	 * @author David Romero Alcaide
	 * @param hash1
	 */
	public void updatePassword(String hash1) {
		Assert.notNull(hash1);
		Assert.isTrue(hash1.length() > 5);
		Profesor p = findPrincipal();
		Assert.notNull(p);
		p.getUserAccount().setPassword(hash1);
		save(p);
	}
	
	
	
	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItems(Profesor p) {
		Assert.notNull(p);
		Assert.isTrue(p.isIdentidadConfirmada());
		List<ItemEvaluable> items = Lists.newArrayList();
		getTodosLosAlumnosProfesor(p).stream().map(alumno->{
			return alumno.getItemsEvaluables()
		})
		return items;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar() {
		Collection<ItemEvaluable> items = findAllItems();
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificar(
			Asignatura asign) {
		Collection<ItemEvaluable> items = findAllItems(asign.getProfesor());
		List<FaltaDeAsistencia> faltasList = Lists.newArrayList();
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia
					&& item.getAsignatura().equals(asign)) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				if (!falta.isJustificada()) {
					faltasList.add(falta);
				}
			}
		}
		return faltasList;
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<FaltaDeAsistencia> findAllFaltaSinJustificarMiAsignaturas(
			final Alumno a,Profesor p) {
		Assert.notNull(a);
		Assert.isTrue(p.isIdentidadConfirmada());
		Asignatura asign = getAsignaturaCursoProfesor(a.getCurso(),p);
		Collection<FaltaDeAsistencia> faltas = findAllFaltaSinJustificar(asign);
		Iterable<FaltaDeAsistencia> faltasFiltradas = Iterables.filter(faltas,
				new Predicate<FaltaDeAsistencia>() {

					
					public boolean apply(FaltaDeAsistencia input) {
						boolean bandera = false;
						if (!input.isJustificada()) {
							bandera = input.getAlumno().equals(a);
						}
						return bandera;
					}
				});
		return Lists.newArrayList(faltasFiltradas);
	}

	/**
	 * @author David Romero Alcaide
	 * @param dni
	 * @return
	 */
	public Profesor findByDNI(String dni) {
		Assert.isTrue(dni.length() == 9);
		Profesor p = profesorRepositorio.findByDNI(dni);
		Assert.notNull(p);
		return p;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param profe
	 * @return
	 */
	public Collection<ItemEvaluable> findAllItemsAlumnoProfesor(final Alumno alum,
			Profesor profe) {
		Assert.notNull(profe);
		Assert.isTrue(profe.isIdentidadConfirmada());
		Collection<ItemEvaluable> itemsProfesor = findAllItems(profe);
		Iterable<ItemEvaluable> itemsProfesorAlumno = Iterables.filter(itemsProfesor,
				new Predicate<ItemEvaluable>() {

					
					public boolean apply(ItemEvaluable input) {
						return checkItemEvaluablePerteneceAAlumno(input,alum);
					}

					
				});
		List<ItemEvaluable> itemsProfesorAlumnoList = Lists.newArrayList(itemsProfesorAlumno);
		return itemsProfesorAlumnoList;
	}

	private boolean checkItemEvaluablePerteneceAAlumno(
			ItemEvaluable item,Alumno alum) {
		return item.getAlumno().equals(alum);
	}

	
	public List<PadreMadreOTutor> getTutoresAlumnosPertenecientesProfesor(Profesor profesor){
		List<PadreMadreOTutor> tutores = Lists.newArrayList();
		List<Alumno> alumnosProfesor = (List<Alumno>) getTodosLosAlumnosProfesor(profesor);
		for ( Alumno alumno : alumnosProfesor ){
			if (alumno.getPadresMadresOTutores() != null && alumno.getPadresMadresOTutores().size() > 0){
				tutores.addAll(alumno.getPadresMadresOTutores());
			}
		}
		return tutores;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:26:58.479
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:58.479
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:58.479
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:26:58.479
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
Caused by: java.lang.NullPointerException
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-17 23:26:58.479
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-17 23:26:58.573
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-17 23:26:58.573
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException

!ENTRY org.eclipse.jdt.core 4 4 2015-04-18 00:12:19.500
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * AlumnoService.java
 * appEducacional
 * 27/01/2014 09:06:00
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

/**
 * imports
 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.Materia;
import com.app.domain.model.types.NotaPorEvaluacion;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Retraso;
import com.app.domain.repositories.AlumnoRepository;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Transactional
@Service
/**
 * @author David Romero Alcaide
 *
 */
public class AlumnoService {

	/**
	 * Constructor
	 */
	public AlumnoService() {
		super();

	}
	
	/**
	 * Log
	 */
	private static final Logger LOGGER = Logger
			.getLogger(AlumnoService.class);

	@Autowired
	/**
	 * Repositorio para interactuar con la base de datos
	 */
	private AlumnoRepository alumnoRepositorio;

	// Servicios gestionados

	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoService cursoService;
	
	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	/**
	 * Servicio para el item evaluable falta de asistencia
	 */
	private RetrasoService retrasoService;

	@Autowired
	/**
	 * 
	 */
	private ProfesorService profesorService;

	@Autowired
	/**
	 * 
	 */
	private NotaPorEvaluacionService notaPorEvaluacionService;

	@Autowired
	/**
	 * 
	 */
	private EvaluacionService evaluacionService;

	@Autowired
	/**
	 * 
	 */
	private PadreMadreOTutorService tutorService;

	// Application context
	@Autowired
	/**
	 * 
	 */
	private ApplicationContext appContext;

	// Métodos CRUD

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Alumno create() {
		Alumno a = new Alumno();
		return a;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> findAll() {
		List<Alumno> ite;
		ite = alumnoRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public Alumno findOne(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		return alumnoRepositorio.findOne(alumnoId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void save(Alumno alumno) {
		Assert.notNull(alumno);
		alumnoRepositorio.save(alumno);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void delete(Alumno alumno) {
		Assert.notNull(alumno);
		Assert.isTrue(alumno.getId() > 0);
		alumnoRepositorio.delete(alumno);
	}

	// Otros métodos de negocio

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @param alumno
	 */
	public void establecerRetraso(Materia a, Alumno alumno) {
		Assert.notNull(a, "pasarLista.asignatura");
		Assert.notNull(alumno, "pasarLista.idAlumno");
		String except = "pasarLista.cursoAlum";
		Assert.isTrue(a.getCurso().getAlumnos().contains(alumno),
				except);
		Assert.isTrue(!(existeRetrasoEnAsignaturaParaHoy(a, alumno)),
				"pasarLista.yaExiste");

		Assert.isTrue(a.getProfesor().isIdentidadConfirmada(),
				except);

		/*
		 *  Es necesario que este creado el dia
		 */

		ItemEvaluable item = retrasoService.create();

		item.setFecha(new Date(System.currentTimeMillis()));
		item.setMateria(a);
		item.setCalificacion(0.0);
		item.setEvaluacion(evaluacionService.findByDate(new Date(System
				.currentTimeMillis())));
		retrasoService.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 * @param a
	 * @param asig
	 */
	private boolean existeRetrasoEnAsignaturaParaHoy(Materia asig, Alumno a) {
		boolean result = false;
		Assert.isTrue(asig.getProfesor().isIdentidadConfirmada());
		for (ItemEvaluable items : a.getItemsEvaluables()) {
			if (items instanceof Retraso && items.getMateria().equals(asig)) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Obtener los items evaluables de un alumno
	 * 
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<ItemEvaluable> obtenerItemsAlumno(Alumno alum) {
		return Lists.newArrayList(alumnoRepositorio.getAllItemsEvaluables(alum
				.getId()));
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<NotaPorEvaluacion> obtenerNotasPorEvaluacion(Alumno alum,Materia asignatura) {
		Map<Class<? extends ItemEvaluable>, Integer> criterios = asignatura.getCriteriosDeEvaluacion();
		Assert.isTrue(criterios.size() > 0);
		List<NotaPorEvaluacion> notas = Lists.newArrayList();
		List<List<Integer>> contadores = new ArrayList<List<Integer>>();
		List<List<Double>> medias = new ArrayList<List<Double>>();
		iniciarContadores(medias, contadores);
		calcularMediasDeNotas(alum, asignatura, contadores, medias);
		List<NotaPorEvaluacion> notasDelAlumnoEnAsignatura = notaPorEvaluacionService
				.getNotasPorEvaluacion(alum, asignatura);
		Assert.isTrue(notasDelAlumnoEnAsignatura.size() == 3);
		double nota = -1;
		
		nota = calcularNotaEvaluacion(medias.get(0), contadores.get(0), criterios);
		NotaPorEvaluacion nota1 = notasDelAlumnoEnAsignatura.get(0);
		nota1.setNotaFinal(nota);
		nota1.setAlumno(alum);
		nota1.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota1);

		this.save(alum);
		notas.add(nota1);

		nota = calcularNotaEvaluacion(medias.get(1), contadores.get(1), criterios);
		NotaPorEvaluacion nota2 = notasDelAlumnoEnAsignatura.get(1);
		nota2.setNotaFinal(nota);
		nota2.setAlumno(alum);
		nota2.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota2);

		this.save(alum);
		notas.add(nota2);
		nota = calcularNotaEvaluacion(medias.get(2), contadores.get(2), criterios);
		NotaPorEvaluacion nota3 = notasDelAlumnoEnAsignatura.get(2);
		nota3.setNotaFinal(nota);
		nota3.setAlumno(alum);
		nota3.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota3);

		this.save(alum);
		notas.add(nota3);
		return notas;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @param contadores
	 * @param medias
	 */
	private void calcularMediasDeNotas(Alumno alum, Materia
			asignatura,
			List<List<Integer>> contadores, List<List<Double>> medias) {
		for (ItemEvaluable item : obtenerItemsAlumnoAsignatura(alum, asignatura)) {
			calcularMediaItemsEvaluacion(medias, contadores, item, 0);
			calcularMediaItemsEvaluacion(medias, contadores, item, 1);
			calcularMediaItemsEvaluacion(medias, contadores, item, 2);
		}
	}

	/**
	 * Inicia los contadores y las sumas a 0
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 */
	private void iniciarContadores(List<List<Double>> medias,
			List<List<Integer>> contadores) {
		for (int i = 0; i < 3; i++) {
			medias.add(i, new ArrayList<Double>());
			contadores.add(i, new ArrayList<Integer>());
			for (int ii = 0; ii < 8; ii++) {
				medias.get(i).add(ii, 0.0);
				contadores.get(i).add(ii, 0);
			}
		}
	}

	/**
	 * Obtiene las medias de los items
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param item
	 * @param evaluacion
	 */
	private void calcularMediaItemsEvaluacion(List<List<Double>> medias,
			List<List<Integer>> contadores, ItemEvaluable item, int evaluacion) {
		Assert.notNull(item.getEvaluacion());
		String pack = "com.app.domain.model.types.itemsevaluables.";
		if (item.getEvaluacion().getIndicador() == (evaluacion + 1)) {
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Examen") == 0) {
				Double notaVieja = medias.get(evaluacion).get(4);
				medias.get(evaluacion).set(4,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(4);
				contadores.get(evaluacion).set(4, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Actividad") == 0) {
				Double notaVieja = medias.get(evaluacion).get(1);
				medias.get(evaluacion).set(1,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(1);
				contadores.get(evaluacion).set(1, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Trabajo") == 0) {
				Double notaVieja = medias.get(evaluacion).get(7);
				medias.get(evaluacion).set(7,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(7);
				contadores.get(evaluacion).set(7, contAntiguo + 1);
			}
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @return
	 */
	public Collection<ItemEvaluable> obtenerItemsAlumnoAsignatura(Alumno alum,
			Asignatura asignatura) {
		Assert.notNull(asignatura);
		Assert.notNull(alum);
		return alumnoRepositorio.getAllItemsEvaluablesByAsignatura(
				alum.getId(), asignatura.getId());
	}

	/**
	 * Calcula la nota para una asignatura
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param criterios
	 * @param nota
	 * @return
	 */
	private double calcularNotaEvaluacion(List<Double> medias,
			List<Integer> contadores, Map<String, Integer> criterios) {
		double mediaExamen, mediaTrabajo, mediaActividad;
		if (contadores.get(4) == 0) {
			mediaExamen = 0.0;
		} else {
			mediaExamen = medias.get(4) / contadores.get(4);
		}
		if (contadores.get(7) == 0) {
			mediaTrabajo = 0.0;
		} else {
			mediaTrabajo = medias.get(7) / contadores.get(7);
		}
		if (contadores.get(1) == 0) {
			mediaActividad = 0.0;
		} else {
			mediaActividad = medias.get(1) / contadores.get(1);
		}
		double notaTotal = 0.0;

		Set<Entry<String, Integer>> conjuntoPares = criterios.entrySet();
		for (Entry<String, Integer> entry : conjuntoPares) {
			if (entry.getKey().equals("Examen")) {
				notaTotal += mediaExamen * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Trabajo")) {
				notaTotal += mediaTrabajo * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Actividad")) {
				notaTotal += mediaActividad * entry.getValue() / 100;
			}
		}
		
		return notaTotal;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public List<PadreMadreOTutor> getTutores(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		Alumno alum = findOne(alumnoId);
		Assert.notNull(alum);
		return Lists.newArrayList(alum.getPadresMadresOTutores());
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void establecerItemEvaluacion(Date fecha, Alumno alumn,
			Materia asig, String tipoNota, int calificacion) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");

		ItemEvaluable item = servicio.create();
		if (calificacion < 5) {
			item.setTitulo(tipoNota + ", No trabaja");
		} else {
			item.setTitulo(tipoNota + ", Si trabaja");
		}

		item.setFecha(fecha);
		item.setMateria(asig);
		item.setCalificacion(calificacion);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<Profesor> getProfesores(Alumno alum) {
		Set<Profesor> profesores = Sets.newHashSet();
		alum.getCursos().stream().filter(curso->{
			return curso.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(curso->)
		return profesores;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnosImportados
	 * @throws ParseException
	 */
	public void guardarAlumnosImportados(List<String[]> alumnosImportados)
			throws ParseException {
		for (String[] alumnoParseado : alumnosImportados) {
			Alumno a = this.create(alumnoParseado);

			for (Alumno temp : cursoService.getAlumnosEnCurso(a.getCurso()
					.getId())) {
				if (temp.getNombre().trim().compareTo(a.getNombre().trim()) == 0
						&& temp.getApellidos().trim()
								.compareTo(a.getApellidos().trim()) == 0
						&& new Date(temp.getFechaNacimiento().getTime())
								.equals(a.getFechaNacimiento())) {
					throw new IllegalArgumentException("El alumno "
							+ temp.getNombre() + temp.getApellidos()
							+ " ya está registrado en el sistema");
				}
			}
			alumnoRepositorio.save(a);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoParseado
	 * @return
	 * @throws ParseException
	 */
	private Alumno create(String[] alumnoParseado) throws ParseException {
		Alumno a = create();
		a.setNombre(alumnoParseado[0].trim());
		a.setApellidos(alumnoParseado[1].trim());
		String curso = alumnoParseado[2].trim();
		int nivel = Integer.valueOf(curso.split(" ")[0]);
		String nivelE = curso.split(" ")[1];
		char iden = curso.split(" ")[2].charAt(0);
		Curso c = cursoService.find(nivel, nivelE, iden);
		Assert.notNull(c);
		Assert.isTrue(profesorService.getCursosImparteDocencia().contains(c));
		a.setCurso(c);
		SimpleDateFormat sp = new SimpleDateFormat("mm/dd/yyyy");
		a.setFechaNacimiento(sp.parse(alumnoParseado[3]));
		try {
			a.setPendiente(alumnoParseado[4].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setPendiente(" ");
		}
		try {
			a.setRepiteCurso(alumnoParseado[5].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setRepiteCurso(" ");
		}
		return a;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void crearItemEvaluacion(Date fecha, Alumno alumn, Asignatura asig,
			String tipoNota, String titulo) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");
		ItemEvaluable item = servicio.create();
		item.setTitulo(titulo);
		item.setFecha(fecha);
		item.setAsignatura(asig);
		item.setCalificacion(0);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param nombre
	 * @param apellidos
	 * @param c
	 * @param fechaNacimiento
	 * @return
	 */
	public Alumno findAlumno(String nombre, String apellidos, Curso c,
			Date fechaNacimiento) {
		Alumno alumnoBuscado = null;
		PadreMadreOTutor tutor = tutorService.findPrincipal();
		Assert.notNull(tutor);
		Assert.isTrue(tutor.isIdentidadConfirmada());
		Collection<Alumno> primerFiltro = alumnoRepositorio
				.findByCursoYFechaNacimiento(c.getId(), fechaNacimiento);
		for (Alumno a : primerFiltro) {
			if (a.getApellidos().equals(apellidos)
					&& a.getApellidos().compareTo(apellidos) == 0
					&& a.getNombre().equals(nombre)
					&& a.getNombre().compareTo(nombre) == 0
					&& !a.getPadresMadresOTutores().contains(tutor)
					&& a.getPadresMadresOTutores().size() <= 2) {
				alumnoBuscado = a;
			}
		}
		return alumnoBuscado;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param tutor
	 */
	public void vincularConProfesor(Alumno alum, PadreMadreOTutor tutor) {
		Assert.notNull(tutor);
		Assert.isTrue(!alum.getPadresMadresOTutores().contains(tutor));
		alum.addPadreMadreOTutor(tutor);
		tutor.addTutorando(alum);
		save(alum);
		tutorService.save(tutor);
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public Collection<FaltaDeAsistencia> getFaltasAlumno(Alumno alum) {
		List<FaltaDeAsistencia> faltas = Lists.newArrayList();
		Collection<ItemEvaluable> items = alumnoRepositorio
				.getAllItemsEvaluables(alum.getId());
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				faltas.add(falta);
			}
		}
		return faltas;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:19.500
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:19.516
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:19.516
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:19.516
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:19.516
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-18 00:12:21.091
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * AlumnoService.java
 * appEducacional
 * 27/01/2014 09:06:00
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

/**
 * imports
 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.Materia;
import com.app.domain.model.types.NotaPorEvaluacion;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Retraso;
import com.app.domain.repositories.AlumnoRepository;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Transactional
@Service
/**
 * @author David Romero Alcaide
 *
 */
public class AlumnoService {

	/**
	 * Constructor
	 */
	public AlumnoService() {
		super();

	}
	
	/**
	 * Log
	 */
	private static final Logger LOGGER = Logger
			.getLogger(AlumnoService.class);

	@Autowired
	/**
	 * Repositorio para interactuar con la base de datos
	 */
	private AlumnoRepository alumnoRepositorio;

	// Servicios gestionados

	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoService cursoService;
	
	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	/**
	 * Servicio para el item evaluable falta de asistencia
	 */
	private RetrasoService retrasoService;

	@Autowired
	/**
	 * 
	 */
	private ProfesorService profesorService;

	@Autowired
	/**
	 * 
	 */
	private NotaPorEvaluacionService notaPorEvaluacionService;

	@Autowired
	/**
	 * 
	 */
	private EvaluacionService evaluacionService;

	@Autowired
	/**
	 * 
	 */
	private PadreMadreOTutorService tutorService;

	// Application context
	@Autowired
	/**
	 * 
	 */
	private ApplicationContext appContext;

	// Métodos CRUD

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Alumno create() {
		Alumno a = new Alumno();
		return a;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> findAll() {
		List<Alumno> ite;
		ite = alumnoRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public Alumno findOne(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		return alumnoRepositorio.findOne(alumnoId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void save(Alumno alumno) {
		Assert.notNull(alumno);
		alumnoRepositorio.save(alumno);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void delete(Alumno alumno) {
		Assert.notNull(alumno);
		Assert.isTrue(alumno.getId() > 0);
		alumnoRepositorio.delete(alumno);
	}

	// Otros métodos de negocio

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @param alumno
	 */
	public void establecerRetraso(Materia a, Alumno alumno) {
		Assert.notNull(a, "pasarLista.asignatura");
		Assert.notNull(alumno, "pasarLista.idAlumno");
		String except = "pasarLista.cursoAlum";
		Assert.isTrue(a.getCurso().getAlumnos().contains(alumno),
				except);
		Assert.isTrue(!(existeRetrasoEnAsignaturaParaHoy(a, alumno)),
				"pasarLista.yaExiste");

		Assert.isTrue(a.getProfesor().isIdentidadConfirmada(),
				except);

		/*
		 *  Es necesario que este creado el dia
		 */

		ItemEvaluable item = retrasoService.create();

		item.setFecha(new Date(System.currentTimeMillis()));
		item.setMateria(a);
		item.setCalificacion(0.0);
		item.setEvaluacion(evaluacionService.findByDate(new Date(System
				.currentTimeMillis())));
		retrasoService.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 * @param a
	 * @param asig
	 */
	private boolean existeRetrasoEnAsignaturaParaHoy(Materia asig, Alumno a) {
		boolean result = false;
		Assert.isTrue(asig.getProfesor().isIdentidadConfirmada());
		for (ItemEvaluable items : a.getItemsEvaluables()) {
			if (items instanceof Retraso && items.getMateria().equals(asig)) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Obtener los items evaluables de un alumno
	 * 
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<ItemEvaluable> obtenerItemsAlumno(Alumno alum) {
		return Lists.newArrayList(alumnoRepositorio.getAllItemsEvaluables(alum
				.getId()));
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<NotaPorEvaluacion> obtenerNotasPorEvaluacion(Alumno alum,Materia asignatura) {
		Map<Class<? extends ItemEvaluable>, Integer> criterios = asignatura.getCriteriosDeEvaluacion();
		Assert.isTrue(criterios.size() > 0);
		List<NotaPorEvaluacion> notas = Lists.newArrayList();
		List<List<Integer>> contadores = new ArrayList<List<Integer>>();
		List<List<Double>> medias = new ArrayList<List<Double>>();
		iniciarContadores(medias, contadores);
		calcularMediasDeNotas(alum, asignatura, contadores, medias);
		List<NotaPorEvaluacion> notasDelAlumnoEnAsignatura = notaPorEvaluacionService
				.getNotasPorEvaluacion(alum, asignatura);
		Assert.isTrue(notasDelAlumnoEnAsignatura.size() == 3);
		double nota = -1;
		
		nota = calcularNotaEvaluacion(medias.get(0), contadores.get(0), criterios);
		NotaPorEvaluacion nota1 = notasDelAlumnoEnAsignatura.get(0);
		nota1.setNotaFinal(nota);
		nota1.setAlumno(alum);
		nota1.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota1);

		this.save(alum);
		notas.add(nota1);

		nota = calcularNotaEvaluacion(medias.get(1), contadores.get(1), criterios);
		NotaPorEvaluacion nota2 = notasDelAlumnoEnAsignatura.get(1);
		nota2.setNotaFinal(nota);
		nota2.setAlumno(alum);
		nota2.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota2);

		this.save(alum);
		notas.add(nota2);
		nota = calcularNotaEvaluacion(medias.get(2), contadores.get(2), criterios);
		NotaPorEvaluacion nota3 = notasDelAlumnoEnAsignatura.get(2);
		nota3.setNotaFinal(nota);
		nota3.setAlumno(alum);
		nota3.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota3);

		this.save(alum);
		notas.add(nota3);
		return notas;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @param contadores
	 * @param medias
	 */
	private void calcularMediasDeNotas(Alumno alum, Materia
			asignatura,
			List<List<Integer>> contadores, List<List<Double>> medias) {
		for (ItemEvaluable item : obtenerItemsAlumnoAsignatura(alum, asignatura)) {
			calcularMediaItemsEvaluacion(medias, contadores, item, 0);
			calcularMediaItemsEvaluacion(medias, contadores, item, 1);
			calcularMediaItemsEvaluacion(medias, contadores, item, 2);
		}
	}

	/**
	 * Inicia los contadores y las sumas a 0
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 */
	private void iniciarContadores(List<List<Double>> medias,
			List<List<Integer>> contadores) {
		for (int i = 0; i < 3; i++) {
			medias.add(i, new ArrayList<Double>());
			contadores.add(i, new ArrayList<Integer>());
			for (int ii = 0; ii < 8; ii++) {
				medias.get(i).add(ii, 0.0);
				contadores.get(i).add(ii, 0);
			}
		}
	}

	/**
	 * Obtiene las medias de los items
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param item
	 * @param evaluacion
	 */
	private void calcularMediaItemsEvaluacion(List<List<Double>> medias,
			List<List<Integer>> contadores, ItemEvaluable item, int evaluacion) {
		Assert.notNull(item.getEvaluacion());
		String pack = "com.app.domain.model.types.itemsevaluables.";
		if (item.getEvaluacion().getIndicador() == (evaluacion + 1)) {
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Examen") == 0) {
				Double notaVieja = medias.get(evaluacion).get(4);
				medias.get(evaluacion).set(4,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(4);
				contadores.get(evaluacion).set(4, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Actividad") == 0) {
				Double notaVieja = medias.get(evaluacion).get(1);
				medias.get(evaluacion).set(1,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(1);
				contadores.get(evaluacion).set(1, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Trabajo") == 0) {
				Double notaVieja = medias.get(evaluacion).get(7);
				medias.get(evaluacion).set(7,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(7);
				contadores.get(evaluacion).set(7, contAntiguo + 1);
			}
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @return
	 */
	public Collection<ItemEvaluable> obtenerItemsAlumnoAsignatura(Alumno alum,
			Asignatura asignatura) {
		Assert.notNull(asignatura);
		Assert.notNull(alum);
		return alumnoRepositorio.getAllItemsEvaluablesByAsignatura(
				alum.getId(), asignatura.getId());
	}

	/**
	 * Calcula la nota para una asignatura
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param criterios
	 * @param nota
	 * @return
	 */
	private double calcularNotaEvaluacion(List<Double> medias,
			List<Integer> contadores, Map<String, Integer> criterios) {
		double mediaExamen, mediaTrabajo, mediaActividad;
		if (contadores.get(4) == 0) {
			mediaExamen = 0.0;
		} else {
			mediaExamen = medias.get(4) / contadores.get(4);
		}
		if (contadores.get(7) == 0) {
			mediaTrabajo = 0.0;
		} else {
			mediaTrabajo = medias.get(7) / contadores.get(7);
		}
		if (contadores.get(1) == 0) {
			mediaActividad = 0.0;
		} else {
			mediaActividad = medias.get(1) / contadores.get(1);
		}
		double notaTotal = 0.0;

		Set<Entry<String, Integer>> conjuntoPares = criterios.entrySet();
		for (Entry<String, Integer> entry : conjuntoPares) {
			if (entry.getKey().equals("Examen")) {
				notaTotal += mediaExamen * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Trabajo")) {
				notaTotal += mediaTrabajo * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Actividad")) {
				notaTotal += mediaActividad * entry.getValue() / 100;
			}
		}
		
		return notaTotal;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public List<PadreMadreOTutor> getTutores(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		Alumno alum = findOne(alumnoId);
		Assert.notNull(alum);
		return Lists.newArrayList(alum.getPadresMadresOTutores());
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void establecerItemEvaluacion(Date fecha, Alumno alumn,
			Materia asig, String tipoNota, int calificacion) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");

		ItemEvaluable item = servicio.create();
		if (calificacion < 5) {
			item.setTitulo(tipoNota + ", No trabaja");
		} else {
			item.setTitulo(tipoNota + ", Si trabaja");
		}

		item.setFecha(fecha);
		item.setMateria(asig);
		item.setCalificacion(calificacion);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<Profesor> getProfesores(Alumno alum) {
		Set<Profesor> profesores = Sets.newHashSet();
		alum.getCursos().stream().filter(curso->{
			return curso.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(curso->{)
		return profesores;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnosImportados
	 * @throws ParseException
	 */
	public void guardarAlumnosImportados(List<String[]> alumnosImportados)
			throws ParseException {
		for (String[] alumnoParseado : alumnosImportados) {
			Alumno a = this.create(alumnoParseado);

			for (Alumno temp : cursoService.getAlumnosEnCurso(a.getCurso()
					.getId())) {
				if (temp.getNombre().trim().compareTo(a.getNombre().trim()) == 0
						&& temp.getApellidos().trim()
								.compareTo(a.getApellidos().trim()) == 0
						&& new Date(temp.getFechaNacimiento().getTime())
								.equals(a.getFechaNacimiento())) {
					throw new IllegalArgumentException("El alumno "
							+ temp.getNombre() + temp.getApellidos()
							+ " ya está registrado en el sistema");
				}
			}
			alumnoRepositorio.save(a);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoParseado
	 * @return
	 * @throws ParseException
	 */
	private Alumno create(String[] alumnoParseado) throws ParseException {
		Alumno a = create();
		a.setNombre(alumnoParseado[0].trim());
		a.setApellidos(alumnoParseado[1].trim());
		String curso = alumnoParseado[2].trim();
		int nivel = Integer.valueOf(curso.split(" ")[0]);
		String nivelE = curso.split(" ")[1];
		char iden = curso.split(" ")[2].charAt(0);
		Curso c = cursoService.find(nivel, nivelE, iden);
		Assert.notNull(c);
		Assert.isTrue(profesorService.getCursosImparteDocencia().contains(c));
		a.setCurso(c);
		SimpleDateFormat sp = new SimpleDateFormat("mm/dd/yyyy");
		a.setFechaNacimiento(sp.parse(alumnoParseado[3]));
		try {
			a.setPendiente(alumnoParseado[4].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setPendiente(" ");
		}
		try {
			a.setRepiteCurso(alumnoParseado[5].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setRepiteCurso(" ");
		}
		return a;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void crearItemEvaluacion(Date fecha, Alumno alumn, Asignatura asig,
			String tipoNota, String titulo) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");
		ItemEvaluable item = servicio.create();
		item.setTitulo(titulo);
		item.setFecha(fecha);
		item.setAsignatura(asig);
		item.setCalificacion(0);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param nombre
	 * @param apellidos
	 * @param c
	 * @param fechaNacimiento
	 * @return
	 */
	public Alumno findAlumno(String nombre, String apellidos, Curso c,
			Date fechaNacimiento) {
		Alumno alumnoBuscado = null;
		PadreMadreOTutor tutor = tutorService.findPrincipal();
		Assert.notNull(tutor);
		Assert.isTrue(tutor.isIdentidadConfirmada());
		Collection<Alumno> primerFiltro = alumnoRepositorio
				.findByCursoYFechaNacimiento(c.getId(), fechaNacimiento);
		for (Alumno a : primerFiltro) {
			if (a.getApellidos().equals(apellidos)
					&& a.getApellidos().compareTo(apellidos) == 0
					&& a.getNombre().equals(nombre)
					&& a.getNombre().compareTo(nombre) == 0
					&& !a.getPadresMadresOTutores().contains(tutor)
					&& a.getPadresMadresOTutores().size() <= 2) {
				alumnoBuscado = a;
			}
		}
		return alumnoBuscado;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param tutor
	 */
	public void vincularConProfesor(Alumno alum, PadreMadreOTutor tutor) {
		Assert.notNull(tutor);
		Assert.isTrue(!alum.getPadresMadresOTutores().contains(tutor));
		alum.addPadreMadreOTutor(tutor);
		tutor.addTutorando(alum);
		save(alum);
		tutorService.save(tutor);
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public Collection<FaltaDeAsistencia> getFaltasAlumno(Alumno alum) {
		List<FaltaDeAsistencia> faltas = Lists.newArrayList();
		Collection<ItemEvaluable> items = alumnoRepositorio
				.getAllItemsEvaluables(alum.getId());
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				faltas.add(falta);
			}
		}
		return faltas;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:21.093
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:21.093
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:21.094
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:21.095
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:21.096
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-18 00:12:28.799
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * AlumnoService.java
 * appEducacional
 * 27/01/2014 09:06:00
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

/**
 * imports
 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.Materia;
import com.app.domain.model.types.NotaPorEvaluacion;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Retraso;
import com.app.domain.repositories.AlumnoRepository;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Transactional
@Service
/**
 * @author David Romero Alcaide
 *
 */
public class AlumnoService {

	/**
	 * Constructor
	 */
	public AlumnoService() {
		super();

	}
	
	/**
	 * Log
	 */
	private static final Logger LOGGER = Logger
			.getLogger(AlumnoService.class);

	@Autowired
	/**
	 * Repositorio para interactuar con la base de datos
	 */
	private AlumnoRepository alumnoRepositorio;

	// Servicios gestionados

	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoService cursoService;
	
	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	/**
	 * Servicio para el item evaluable falta de asistencia
	 */
	private RetrasoService retrasoService;

	@Autowired
	/**
	 * 
	 */
	private ProfesorService profesorService;

	@Autowired
	/**
	 * 
	 */
	private NotaPorEvaluacionService notaPorEvaluacionService;

	@Autowired
	/**
	 * 
	 */
	private EvaluacionService evaluacionService;

	@Autowired
	/**
	 * 
	 */
	private PadreMadreOTutorService tutorService;

	// Application context
	@Autowired
	/**
	 * 
	 */
	private ApplicationContext appContext;

	// Métodos CRUD

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Alumno create() {
		Alumno a = new Alumno();
		return a;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> findAll() {
		List<Alumno> ite;
		ite = alumnoRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public Alumno findOne(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		return alumnoRepositorio.findOne(alumnoId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void save(Alumno alumno) {
		Assert.notNull(alumno);
		alumnoRepositorio.save(alumno);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void delete(Alumno alumno) {
		Assert.notNull(alumno);
		Assert.isTrue(alumno.getId() > 0);
		alumnoRepositorio.delete(alumno);
	}

	// Otros métodos de negocio

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @param alumno
	 */
	public void establecerRetraso(Materia a, Alumno alumno) {
		Assert.notNull(a, "pasarLista.asignatura");
		Assert.notNull(alumno, "pasarLista.idAlumno");
		String except = "pasarLista.cursoAlum";
		Assert.isTrue(a.getCurso().getAlumnos().contains(alumno),
				except);
		Assert.isTrue(!(existeRetrasoEnAsignaturaParaHoy(a, alumno)),
				"pasarLista.yaExiste");

		Assert.isTrue(a.getProfesor().isIdentidadConfirmada(),
				except);

		/*
		 *  Es necesario que este creado el dia
		 */

		ItemEvaluable item = retrasoService.create();

		item.setFecha(new Date(System.currentTimeMillis()));
		item.setMateria(a);
		item.setCalificacion(0.0);
		item.setEvaluacion(evaluacionService.findByDate(new Date(System
				.currentTimeMillis())));
		retrasoService.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 * @param a
	 * @param asig
	 */
	private boolean existeRetrasoEnAsignaturaParaHoy(Materia asig, Alumno a) {
		boolean result = false;
		Assert.isTrue(asig.getProfesor().isIdentidadConfirmada());
		for (ItemEvaluable items : a.getItemsEvaluables()) {
			if (items instanceof Retraso && items.getMateria().equals(asig)) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Obtener los items evaluables de un alumno
	 * 
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<ItemEvaluable> obtenerItemsAlumno(Alumno alum) {
		return Lists.newArrayList(alumnoRepositorio.getAllItemsEvaluables(alum
				.getId()));
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<NotaPorEvaluacion> obtenerNotasPorEvaluacion(Alumno alum,Materia asignatura) {
		Map<Class<? extends ItemEvaluable>, Integer> criterios = asignatura.getCriteriosDeEvaluacion();
		Assert.isTrue(criterios.size() > 0);
		List<NotaPorEvaluacion> notas = Lists.newArrayList();
		List<List<Integer>> contadores = new ArrayList<List<Integer>>();
		List<List<Double>> medias = new ArrayList<List<Double>>();
		iniciarContadores(medias, contadores);
		calcularMediasDeNotas(alum, asignatura, contadores, medias);
		List<NotaPorEvaluacion> notasDelAlumnoEnAsignatura = notaPorEvaluacionService
				.getNotasPorEvaluacion(alum, asignatura);
		Assert.isTrue(notasDelAlumnoEnAsignatura.size() == 3);
		double nota = -1;
		
		nota = calcularNotaEvaluacion(medias.get(0), contadores.get(0), criterios);
		NotaPorEvaluacion nota1 = notasDelAlumnoEnAsignatura.get(0);
		nota1.setNotaFinal(nota);
		nota1.setAlumno(alum);
		nota1.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota1);

		this.save(alum);
		notas.add(nota1);

		nota = calcularNotaEvaluacion(medias.get(1), contadores.get(1), criterios);
		NotaPorEvaluacion nota2 = notasDelAlumnoEnAsignatura.get(1);
		nota2.setNotaFinal(nota);
		nota2.setAlumno(alum);
		nota2.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota2);

		this.save(alum);
		notas.add(nota2);
		nota = calcularNotaEvaluacion(medias.get(2), contadores.get(2), criterios);
		NotaPorEvaluacion nota3 = notasDelAlumnoEnAsignatura.get(2);
		nota3.setNotaFinal(nota);
		nota3.setAlumno(alum);
		nota3.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota3);

		this.save(alum);
		notas.add(nota3);
		return notas;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @param contadores
	 * @param medias
	 */
	private void calcularMediasDeNotas(Alumno alum, Materia
			asignatura,
			List<List<Integer>> contadores, List<List<Double>> medias) {
		for (ItemEvaluable item : obtenerItemsAlumnoAsignatura(alum, asignatura)) {
			calcularMediaItemsEvaluacion(medias, contadores, item, 0);
			calcularMediaItemsEvaluacion(medias, contadores, item, 1);
			calcularMediaItemsEvaluacion(medias, contadores, item, 2);
		}
	}

	/**
	 * Inicia los contadores y las sumas a 0
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 */
	private void iniciarContadores(List<List<Double>> medias,
			List<List<Integer>> contadores) {
		for (int i = 0; i < 3; i++) {
			medias.add(i, new ArrayList<Double>());
			contadores.add(i, new ArrayList<Integer>());
			for (int ii = 0; ii < 8; ii++) {
				medias.get(i).add(ii, 0.0);
				contadores.get(i).add(ii, 0);
			}
		}
	}

	/**
	 * Obtiene las medias de los items
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param item
	 * @param evaluacion
	 */
	private void calcularMediaItemsEvaluacion(List<List<Double>> medias,
			List<List<Integer>> contadores, ItemEvaluable item, int evaluacion) {
		Assert.notNull(item.getEvaluacion());
		String pack = "com.app.domain.model.types.itemsevaluables.";
		if (item.getEvaluacion().getIndicador() == (evaluacion + 1)) {
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Examen") == 0) {
				Double notaVieja = medias.get(evaluacion).get(4);
				medias.get(evaluacion).set(4,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(4);
				contadores.get(evaluacion).set(4, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Actividad") == 0) {
				Double notaVieja = medias.get(evaluacion).get(1);
				medias.get(evaluacion).set(1,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(1);
				contadores.get(evaluacion).set(1, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Trabajo") == 0) {
				Double notaVieja = medias.get(evaluacion).get(7);
				medias.get(evaluacion).set(7,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(7);
				contadores.get(evaluacion).set(7, contAntiguo + 1);
			}
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @return
	 */
	public Collection<ItemEvaluable> obtenerItemsAlumnoAsignatura(Alumno alum,
			Asignatura asignatura) {
		Assert.notNull(asignatura);
		Assert.notNull(alum);
		return alumnoRepositorio.getAllItemsEvaluablesByAsignatura(
				alum.getId(), asignatura.getId());
	}

	/**
	 * Calcula la nota para una asignatura
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param criterios
	 * @param nota
	 * @return
	 */
	private double calcularNotaEvaluacion(List<Double> medias,
			List<Integer> contadores, Map<String, Integer> criterios) {
		double mediaExamen, mediaTrabajo, mediaActividad;
		if (contadores.get(4) == 0) {
			mediaExamen = 0.0;
		} else {
			mediaExamen = medias.get(4) / contadores.get(4);
		}
		if (contadores.get(7) == 0) {
			mediaTrabajo = 0.0;
		} else {
			mediaTrabajo = medias.get(7) / contadores.get(7);
		}
		if (contadores.get(1) == 0) {
			mediaActividad = 0.0;
		} else {
			mediaActividad = medias.get(1) / contadores.get(1);
		}
		double notaTotal = 0.0;

		Set<Entry<String, Integer>> conjuntoPares = criterios.entrySet();
		for (Entry<String, Integer> entry : conjuntoPares) {
			if (entry.getKey().equals("Examen")) {
				notaTotal += mediaExamen * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Trabajo")) {
				notaTotal += mediaTrabajo * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Actividad")) {
				notaTotal += mediaActividad * entry.getValue() / 100;
			}
		}
		
		return notaTotal;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public List<PadreMadreOTutor> getTutores(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		Alumno alum = findOne(alumnoId);
		Assert.notNull(alum);
		return Lists.newArrayList(alum.getPadresMadresOTutores());
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void establecerItemEvaluacion(Date fecha, Alumno alumn,
			Materia asig, String tipoNota, int calificacion) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");

		ItemEvaluable item = servicio.create();
		if (calificacion < 5) {
			item.setTitulo(tipoNota + ", No trabaja");
		} else {
			item.setTitulo(tipoNota + ", Si trabaja");
		}

		item.setFecha(fecha);
		item.setMateria(asig);
		item.setCalificacion(calificacion);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<Profesor> getProfesores(Alumno alum) {
		Set<Profesor> profesores = Sets.newHashSet();
		alum.getCursos().stream().filter(curso->{
			return curso.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(curso->{ return  })
		return profesores;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnosImportados
	 * @throws ParseException
	 */
	public void guardarAlumnosImportados(List<String[]> alumnosImportados)
			throws ParseException {
		for (String[] alumnoParseado : alumnosImportados) {
			Alumno a = this.create(alumnoParseado);

			for (Alumno temp : cursoService.getAlumnosEnCurso(a.getCurso()
					.getId())) {
				if (temp.getNombre().trim().compareTo(a.getNombre().trim()) == 0
						&& temp.getApellidos().trim()
								.compareTo(a.getApellidos().trim()) == 0
						&& new Date(temp.getFechaNacimiento().getTime())
								.equals(a.getFechaNacimiento())) {
					throw new IllegalArgumentException("El alumno "
							+ temp.getNombre() + temp.getApellidos()
							+ " ya está registrado en el sistema");
				}
			}
			alumnoRepositorio.save(a);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoParseado
	 * @return
	 * @throws ParseException
	 */
	private Alumno create(String[] alumnoParseado) throws ParseException {
		Alumno a = create();
		a.setNombre(alumnoParseado[0].trim());
		a.setApellidos(alumnoParseado[1].trim());
		String curso = alumnoParseado[2].trim();
		int nivel = Integer.valueOf(curso.split(" ")[0]);
		String nivelE = curso.split(" ")[1];
		char iden = curso.split(" ")[2].charAt(0);
		Curso c = cursoService.find(nivel, nivelE, iden);
		Assert.notNull(c);
		Assert.isTrue(profesorService.getCursosImparteDocencia().contains(c));
		a.setCurso(c);
		SimpleDateFormat sp = new SimpleDateFormat("mm/dd/yyyy");
		a.setFechaNacimiento(sp.parse(alumnoParseado[3]));
		try {
			a.setPendiente(alumnoParseado[4].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setPendiente(" ");
		}
		try {
			a.setRepiteCurso(alumnoParseado[5].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setRepiteCurso(" ");
		}
		return a;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void crearItemEvaluacion(Date fecha, Alumno alumn, Asignatura asig,
			String tipoNota, String titulo) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");
		ItemEvaluable item = servicio.create();
		item.setTitulo(titulo);
		item.setFecha(fecha);
		item.setAsignatura(asig);
		item.setCalificacion(0);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param nombre
	 * @param apellidos
	 * @param c
	 * @param fechaNacimiento
	 * @return
	 */
	public Alumno findAlumno(String nombre, String apellidos, Curso c,
			Date fechaNacimiento) {
		Alumno alumnoBuscado = null;
		PadreMadreOTutor tutor = tutorService.findPrincipal();
		Assert.notNull(tutor);
		Assert.isTrue(tutor.isIdentidadConfirmada());
		Collection<Alumno> primerFiltro = alumnoRepositorio
				.findByCursoYFechaNacimiento(c.getId(), fechaNacimiento);
		for (Alumno a : primerFiltro) {
			if (a.getApellidos().equals(apellidos)
					&& a.getApellidos().compareTo(apellidos) == 0
					&& a.getNombre().equals(nombre)
					&& a.getNombre().compareTo(nombre) == 0
					&& !a.getPadresMadresOTutores().contains(tutor)
					&& a.getPadresMadresOTutores().size() <= 2) {
				alumnoBuscado = a;
			}
		}
		return alumnoBuscado;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param tutor
	 */
	public void vincularConProfesor(Alumno alum, PadreMadreOTutor tutor) {
		Assert.notNull(tutor);
		Assert.isTrue(!alum.getPadresMadresOTutores().contains(tutor));
		alum.addPadreMadreOTutor(tutor);
		tutor.addTutorando(alum);
		save(alum);
		tutorService.save(tutor);
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public Collection<FaltaDeAsistencia> getFaltasAlumno(Alumno alum) {
		List<FaltaDeAsistencia> faltas = Lists.newArrayList();
		Collection<ItemEvaluable> items = alumnoRepositorio
				.getAllItemsEvaluables(alum.getId());
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				faltas.add(falta);
			}
		}
		return faltas;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:28.802
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:28.803
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:28.804
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:28.806
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:28.806
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-18 00:12:31.981
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * AlumnoService.java
 * appEducacional
 * 27/01/2014 09:06:00
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

/**
 * imports
 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.Materia;
import com.app.domain.model.types.NotaPorEvaluacion;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Retraso;
import com.app.domain.repositories.AlumnoRepository;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Transactional
@Service
/**
 * @author David Romero Alcaide
 *
 */
public class AlumnoService {

	/**
	 * Constructor
	 */
	public AlumnoService() {
		super();

	}
	
	/**
	 * Log
	 */
	private static final Logger LOGGER = Logger
			.getLogger(AlumnoService.class);

	@Autowired
	/**
	 * Repositorio para interactuar con la base de datos
	 */
	private AlumnoRepository alumnoRepositorio;

	// Servicios gestionados

	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoService cursoService;
	
	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	/**
	 * Servicio para el item evaluable falta de asistencia
	 */
	private RetrasoService retrasoService;

	@Autowired
	/**
	 * 
	 */
	private ProfesorService profesorService;

	@Autowired
	/**
	 * 
	 */
	private NotaPorEvaluacionService notaPorEvaluacionService;

	@Autowired
	/**
	 * 
	 */
	private EvaluacionService evaluacionService;

	@Autowired
	/**
	 * 
	 */
	private PadreMadreOTutorService tutorService;

	// Application context
	@Autowired
	/**
	 * 
	 */
	private ApplicationContext appContext;

	// Métodos CRUD

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Alumno create() {
		Alumno a = new Alumno();
		return a;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> findAll() {
		List<Alumno> ite;
		ite = alumnoRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public Alumno findOne(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		return alumnoRepositorio.findOne(alumnoId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void save(Alumno alumno) {
		Assert.notNull(alumno);
		alumnoRepositorio.save(alumno);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void delete(Alumno alumno) {
		Assert.notNull(alumno);
		Assert.isTrue(alumno.getId() > 0);
		alumnoRepositorio.delete(alumno);
	}

	// Otros métodos de negocio

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @param alumno
	 */
	public void establecerRetraso(Materia a, Alumno alumno) {
		Assert.notNull(a, "pasarLista.asignatura");
		Assert.notNull(alumno, "pasarLista.idAlumno");
		String except = "pasarLista.cursoAlum";
		Assert.isTrue(a.getCurso().getAlumnos().contains(alumno),
				except);
		Assert.isTrue(!(existeRetrasoEnAsignaturaParaHoy(a, alumno)),
				"pasarLista.yaExiste");

		Assert.isTrue(a.getProfesor().isIdentidadConfirmada(),
				except);

		/*
		 *  Es necesario que este creado el dia
		 */

		ItemEvaluable item = retrasoService.create();

		item.setFecha(new Date(System.currentTimeMillis()));
		item.setMateria(a);
		item.setCalificacion(0.0);
		item.setEvaluacion(evaluacionService.findByDate(new Date(System
				.currentTimeMillis())));
		retrasoService.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 * @param a
	 * @param asig
	 */
	private boolean existeRetrasoEnAsignaturaParaHoy(Materia asig, Alumno a) {
		boolean result = false;
		Assert.isTrue(asig.getProfesor().isIdentidadConfirmada());
		for (ItemEvaluable items : a.getItemsEvaluables()) {
			if (items instanceof Retraso && items.getMateria().equals(asig)) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Obtener los items evaluables de un alumno
	 * 
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<ItemEvaluable> obtenerItemsAlumno(Alumno alum) {
		return Lists.newArrayList(alumnoRepositorio.getAllItemsEvaluables(alum
				.getId()));
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<NotaPorEvaluacion> obtenerNotasPorEvaluacion(Alumno alum,Materia asignatura) {
		Map<Class<? extends ItemEvaluable>, Integer> criterios = asignatura.getCriteriosDeEvaluacion();
		Assert.isTrue(criterios.size() > 0);
		List<NotaPorEvaluacion> notas = Lists.newArrayList();
		List<List<Integer>> contadores = new ArrayList<List<Integer>>();
		List<List<Double>> medias = new ArrayList<List<Double>>();
		iniciarContadores(medias, contadores);
		calcularMediasDeNotas(alum, asignatura, contadores, medias);
		List<NotaPorEvaluacion> notasDelAlumnoEnAsignatura = notaPorEvaluacionService
				.getNotasPorEvaluacion(alum, asignatura);
		Assert.isTrue(notasDelAlumnoEnAsignatura.size() == 3);
		double nota = -1;
		
		nota = calcularNotaEvaluacion(medias.get(0), contadores.get(0), criterios);
		NotaPorEvaluacion nota1 = notasDelAlumnoEnAsignatura.get(0);
		nota1.setNotaFinal(nota);
		nota1.setAlumno(alum);
		nota1.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota1);

		this.save(alum);
		notas.add(nota1);

		nota = calcularNotaEvaluacion(medias.get(1), contadores.get(1), criterios);
		NotaPorEvaluacion nota2 = notasDelAlumnoEnAsignatura.get(1);
		nota2.setNotaFinal(nota);
		nota2.setAlumno(alum);
		nota2.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota2);

		this.save(alum);
		notas.add(nota2);
		nota = calcularNotaEvaluacion(medias.get(2), contadores.get(2), criterios);
		NotaPorEvaluacion nota3 = notasDelAlumnoEnAsignatura.get(2);
		nota3.setNotaFinal(nota);
		nota3.setAlumno(alum);
		nota3.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota3);

		this.save(alum);
		notas.add(nota3);
		return notas;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @param contadores
	 * @param medias
	 */
	private void calcularMediasDeNotas(Alumno alum, Materia
			asignatura,
			List<List<Integer>> contadores, List<List<Double>> medias) {
		for (ItemEvaluable item : obtenerItemsAlumnoAsignatura(alum, asignatura)) {
			calcularMediaItemsEvaluacion(medias, contadores, item, 0);
			calcularMediaItemsEvaluacion(medias, contadores, item, 1);
			calcularMediaItemsEvaluacion(medias, contadores, item, 2);
		}
	}

	/**
	 * Inicia los contadores y las sumas a 0
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 */
	private void iniciarContadores(List<List<Double>> medias,
			List<List<Integer>> contadores) {
		for (int i = 0; i < 3; i++) {
			medias.add(i, new ArrayList<Double>());
			contadores.add(i, new ArrayList<Integer>());
			for (int ii = 0; ii < 8; ii++) {
				medias.get(i).add(ii, 0.0);
				contadores.get(i).add(ii, 0);
			}
		}
	}

	/**
	 * Obtiene las medias de los items
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param item
	 * @param evaluacion
	 */
	private void calcularMediaItemsEvaluacion(List<List<Double>> medias,
			List<List<Integer>> contadores, ItemEvaluable item, int evaluacion) {
		Assert.notNull(item.getEvaluacion());
		String pack = "com.app.domain.model.types.itemsevaluables.";
		if (item.getEvaluacion().getIndicador() == (evaluacion + 1)) {
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Examen") == 0) {
				Double notaVieja = medias.get(evaluacion).get(4);
				medias.get(evaluacion).set(4,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(4);
				contadores.get(evaluacion).set(4, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Actividad") == 0) {
				Double notaVieja = medias.get(evaluacion).get(1);
				medias.get(evaluacion).set(1,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(1);
				contadores.get(evaluacion).set(1, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Trabajo") == 0) {
				Double notaVieja = medias.get(evaluacion).get(7);
				medias.get(evaluacion).set(7,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(7);
				contadores.get(evaluacion).set(7, contAntiguo + 1);
			}
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @return
	 */
	public Collection<ItemEvaluable> obtenerItemsAlumnoAsignatura(Alumno alum,
			Asignatura asignatura) {
		Assert.notNull(asignatura);
		Assert.notNull(alum);
		return alumnoRepositorio.getAllItemsEvaluablesByAsignatura(
				alum.getId(), asignatura.getId());
	}

	/**
	 * Calcula la nota para una asignatura
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param criterios
	 * @param nota
	 * @return
	 */
	private double calcularNotaEvaluacion(List<Double> medias,
			List<Integer> contadores, Map<String, Integer> criterios) {
		double mediaExamen, mediaTrabajo, mediaActividad;
		if (contadores.get(4) == 0) {
			mediaExamen = 0.0;
		} else {
			mediaExamen = medias.get(4) / contadores.get(4);
		}
		if (contadores.get(7) == 0) {
			mediaTrabajo = 0.0;
		} else {
			mediaTrabajo = medias.get(7) / contadores.get(7);
		}
		if (contadores.get(1) == 0) {
			mediaActividad = 0.0;
		} else {
			mediaActividad = medias.get(1) / contadores.get(1);
		}
		double notaTotal = 0.0;

		Set<Entry<String, Integer>> conjuntoPares = criterios.entrySet();
		for (Entry<String, Integer> entry : conjuntoPares) {
			if (entry.getKey().equals("Examen")) {
				notaTotal += mediaExamen * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Trabajo")) {
				notaTotal += mediaTrabajo * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Actividad")) {
				notaTotal += mediaActividad * entry.getValue() / 100;
			}
		}
		
		return notaTotal;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public List<PadreMadreOTutor> getTutores(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		Alumno alum = findOne(alumnoId);
		Assert.notNull(alum);
		return Lists.newArrayList(alum.getPadresMadresOTutores());
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void establecerItemEvaluacion(Date fecha, Alumno alumn,
			Materia asig, String tipoNota, int calificacion) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");

		ItemEvaluable item = servicio.create();
		if (calificacion < 5) {
			item.setTitulo(tipoNota + ", No trabaja");
		} else {
			item.setTitulo(tipoNota + ", Si trabaja");
		}

		item.setFecha(fecha);
		item.setMateria(asig);
		item.setCalificacion(calificacion);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<Profesor> getProfesores(Alumno alum) {
		Set<Profesor> profesores = Sets.newHashSet();
		alum.getCursos().stream().filter(curso->{
			return curso.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(curso->{ return curso.ge })
		return profesores;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnosImportados
	 * @throws ParseException
	 */
	public void guardarAlumnosImportados(List<String[]> alumnosImportados)
			throws ParseException {
		for (String[] alumnoParseado : alumnosImportados) {
			Alumno a = this.create(alumnoParseado);

			for (Alumno temp : cursoService.getAlumnosEnCurso(a.getCurso()
					.getId())) {
				if (temp.getNombre().trim().compareTo(a.getNombre().trim()) == 0
						&& temp.getApellidos().trim()
								.compareTo(a.getApellidos().trim()) == 0
						&& new Date(temp.getFechaNacimiento().getTime())
								.equals(a.getFechaNacimiento())) {
					throw new IllegalArgumentException("El alumno "
							+ temp.getNombre() + temp.getApellidos()
							+ " ya está registrado en el sistema");
				}
			}
			alumnoRepositorio.save(a);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoParseado
	 * @return
	 * @throws ParseException
	 */
	private Alumno create(String[] alumnoParseado) throws ParseException {
		Alumno a = create();
		a.setNombre(alumnoParseado[0].trim());
		a.setApellidos(alumnoParseado[1].trim());
		String curso = alumnoParseado[2].trim();
		int nivel = Integer.valueOf(curso.split(" ")[0]);
		String nivelE = curso.split(" ")[1];
		char iden = curso.split(" ")[2].charAt(0);
		Curso c = cursoService.find(nivel, nivelE, iden);
		Assert.notNull(c);
		Assert.isTrue(profesorService.getCursosImparteDocencia().contains(c));
		a.setCurso(c);
		SimpleDateFormat sp = new SimpleDateFormat("mm/dd/yyyy");
		a.setFechaNacimiento(sp.parse(alumnoParseado[3]));
		try {
			a.setPendiente(alumnoParseado[4].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setPendiente(" ");
		}
		try {
			a.setRepiteCurso(alumnoParseado[5].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setRepiteCurso(" ");
		}
		return a;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void crearItemEvaluacion(Date fecha, Alumno alumn, Asignatura asig,
			String tipoNota, String titulo) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");
		ItemEvaluable item = servicio.create();
		item.setTitulo(titulo);
		item.setFecha(fecha);
		item.setAsignatura(asig);
		item.setCalificacion(0);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param nombre
	 * @param apellidos
	 * @param c
	 * @param fechaNacimiento
	 * @return
	 */
	public Alumno findAlumno(String nombre, String apellidos, Curso c,
			Date fechaNacimiento) {
		Alumno alumnoBuscado = null;
		PadreMadreOTutor tutor = tutorService.findPrincipal();
		Assert.notNull(tutor);
		Assert.isTrue(tutor.isIdentidadConfirmada());
		Collection<Alumno> primerFiltro = alumnoRepositorio
				.findByCursoYFechaNacimiento(c.getId(), fechaNacimiento);
		for (Alumno a : primerFiltro) {
			if (a.getApellidos().equals(apellidos)
					&& a.getApellidos().compareTo(apellidos) == 0
					&& a.getNombre().equals(nombre)
					&& a.getNombre().compareTo(nombre) == 0
					&& !a.getPadresMadresOTutores().contains(tutor)
					&& a.getPadresMadresOTutores().size() <= 2) {
				alumnoBuscado = a;
			}
		}
		return alumnoBuscado;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param tutor
	 */
	public void vincularConProfesor(Alumno alum, PadreMadreOTutor tutor) {
		Assert.notNull(tutor);
		Assert.isTrue(!alum.getPadresMadresOTutores().contains(tutor));
		alum.addPadreMadreOTutor(tutor);
		tutor.addTutorando(alum);
		save(alum);
		tutorService.save(tutor);
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public Collection<FaltaDeAsistencia> getFaltasAlumno(Alumno alum) {
		List<FaltaDeAsistencia> faltas = Lists.newArrayList();
		Collection<ItemEvaluable> items = alumnoRepositorio
				.getAllItemsEvaluables(alum.getId());
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				faltas.add(falta);
			}
		}
		return faltas;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:31.981
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:31.981
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:31.981
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:31.981
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:31.981
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-18 00:12:36.062
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * AlumnoService.java
 * appEducacional
 * 27/01/2014 09:06:00
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

/**
 * imports
 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.Materia;
import com.app.domain.model.types.NotaPorEvaluacion;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Retraso;
import com.app.domain.repositories.AlumnoRepository;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Transactional
@Service
/**
 * @author David Romero Alcaide
 *
 */
public class AlumnoService {

	/**
	 * Constructor
	 */
	public AlumnoService() {
		super();

	}
	
	/**
	 * Log
	 */
	private static final Logger LOGGER = Logger
			.getLogger(AlumnoService.class);

	@Autowired
	/**
	 * Repositorio para interactuar con la base de datos
	 */
	private AlumnoRepository alumnoRepositorio;

	// Servicios gestionados

	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoService cursoService;
	
	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	/**
	 * Servicio para el item evaluable falta de asistencia
	 */
	private RetrasoService retrasoService;

	@Autowired
	/**
	 * 
	 */
	private ProfesorService profesorService;

	@Autowired
	/**
	 * 
	 */
	private NotaPorEvaluacionService notaPorEvaluacionService;

	@Autowired
	/**
	 * 
	 */
	private EvaluacionService evaluacionService;

	@Autowired
	/**
	 * 
	 */
	private PadreMadreOTutorService tutorService;

	// Application context
	@Autowired
	/**
	 * 
	 */
	private ApplicationContext appContext;

	// Métodos CRUD

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Alumno create() {
		Alumno a = new Alumno();
		return a;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> findAll() {
		List<Alumno> ite;
		ite = alumnoRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public Alumno findOne(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		return alumnoRepositorio.findOne(alumnoId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void save(Alumno alumno) {
		Assert.notNull(alumno);
		alumnoRepositorio.save(alumno);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void delete(Alumno alumno) {
		Assert.notNull(alumno);
		Assert.isTrue(alumno.getId() > 0);
		alumnoRepositorio.delete(alumno);
	}

	// Otros métodos de negocio

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @param alumno
	 */
	public void establecerRetraso(Materia a, Alumno alumno) {
		Assert.notNull(a, "pasarLista.asignatura");
		Assert.notNull(alumno, "pasarLista.idAlumno");
		String except = "pasarLista.cursoAlum";
		Assert.isTrue(a.getCurso().getAlumnos().contains(alumno),
				except);
		Assert.isTrue(!(existeRetrasoEnAsignaturaParaHoy(a, alumno)),
				"pasarLista.yaExiste");

		Assert.isTrue(a.getProfesor().isIdentidadConfirmada(),
				except);

		/*
		 *  Es necesario que este creado el dia
		 */

		ItemEvaluable item = retrasoService.create();

		item.setFecha(new Date(System.currentTimeMillis()));
		item.setMateria(a);
		item.setCalificacion(0.0);
		item.setEvaluacion(evaluacionService.findByDate(new Date(System
				.currentTimeMillis())));
		retrasoService.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 * @param a
	 * @param asig
	 */
	private boolean existeRetrasoEnAsignaturaParaHoy(Materia asig, Alumno a) {
		boolean result = false;
		Assert.isTrue(asig.getProfesor().isIdentidadConfirmada());
		for (ItemEvaluable items : a.getItemsEvaluables()) {
			if (items instanceof Retraso && items.getMateria().equals(asig)) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Obtener los items evaluables de un alumno
	 * 
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<ItemEvaluable> obtenerItemsAlumno(Alumno alum) {
		return Lists.newArrayList(alumnoRepositorio.getAllItemsEvaluables(alum
				.getId()));
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<NotaPorEvaluacion> obtenerNotasPorEvaluacion(Alumno alum,Materia asignatura) {
		Map<Class<? extends ItemEvaluable>, Integer> criterios = asignatura.getCriteriosDeEvaluacion();
		Assert.isTrue(criterios.size() > 0);
		List<NotaPorEvaluacion> notas = Lists.newArrayList();
		List<List<Integer>> contadores = new ArrayList<List<Integer>>();
		List<List<Double>> medias = new ArrayList<List<Double>>();
		iniciarContadores(medias, contadores);
		calcularMediasDeNotas(alum, asignatura, contadores, medias);
		List<NotaPorEvaluacion> notasDelAlumnoEnAsignatura = notaPorEvaluacionService
				.getNotasPorEvaluacion(alum, asignatura);
		Assert.isTrue(notasDelAlumnoEnAsignatura.size() == 3);
		double nota = -1;
		
		nota = calcularNotaEvaluacion(medias.get(0), contadores.get(0), criterios);
		NotaPorEvaluacion nota1 = notasDelAlumnoEnAsignatura.get(0);
		nota1.setNotaFinal(nota);
		nota1.setAlumno(alum);
		nota1.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota1);

		this.save(alum);
		notas.add(nota1);

		nota = calcularNotaEvaluacion(medias.get(1), contadores.get(1), criterios);
		NotaPorEvaluacion nota2 = notasDelAlumnoEnAsignatura.get(1);
		nota2.setNotaFinal(nota);
		nota2.setAlumno(alum);
		nota2.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota2);

		this.save(alum);
		notas.add(nota2);
		nota = calcularNotaEvaluacion(medias.get(2), contadores.get(2), criterios);
		NotaPorEvaluacion nota3 = notasDelAlumnoEnAsignatura.get(2);
		nota3.setNotaFinal(nota);
		nota3.setAlumno(alum);
		nota3.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota3);

		this.save(alum);
		notas.add(nota3);
		return notas;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @param contadores
	 * @param medias
	 */
	private void calcularMediasDeNotas(Alumno alum, Materia
			asignatura,
			List<List<Integer>> contadores, List<List<Double>> medias) {
		for (ItemEvaluable item : obtenerItemsAlumnoAsignatura(alum, asignatura)) {
			calcularMediaItemsEvaluacion(medias, contadores, item, 0);
			calcularMediaItemsEvaluacion(medias, contadores, item, 1);
			calcularMediaItemsEvaluacion(medias, contadores, item, 2);
		}
	}

	/**
	 * Inicia los contadores y las sumas a 0
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 */
	private void iniciarContadores(List<List<Double>> medias,
			List<List<Integer>> contadores) {
		for (int i = 0; i < 3; i++) {
			medias.add(i, new ArrayList<Double>());
			contadores.add(i, new ArrayList<Integer>());
			for (int ii = 0; ii < 8; ii++) {
				medias.get(i).add(ii, 0.0);
				contadores.get(i).add(ii, 0);
			}
		}
	}

	/**
	 * Obtiene las medias de los items
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param item
	 * @param evaluacion
	 */
	private void calcularMediaItemsEvaluacion(List<List<Double>> medias,
			List<List<Integer>> contadores, ItemEvaluable item, int evaluacion) {
		Assert.notNull(item.getEvaluacion());
		String pack = "com.app.domain.model.types.itemsevaluables.";
		if (item.getEvaluacion().getIndicador() == (evaluacion + 1)) {
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Examen") == 0) {
				Double notaVieja = medias.get(evaluacion).get(4);
				medias.get(evaluacion).set(4,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(4);
				contadores.get(evaluacion).set(4, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Actividad") == 0) {
				Double notaVieja = medias.get(evaluacion).get(1);
				medias.get(evaluacion).set(1,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(1);
				contadores.get(evaluacion).set(1, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Trabajo") == 0) {
				Double notaVieja = medias.get(evaluacion).get(7);
				medias.get(evaluacion).set(7,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(7);
				contadores.get(evaluacion).set(7, contAntiguo + 1);
			}
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @return
	 */
	public Collection<ItemEvaluable> obtenerItemsAlumnoAsignatura(Alumno alum,
			Asignatura asignatura) {
		Assert.notNull(asignatura);
		Assert.notNull(alum);
		return alumnoRepositorio.getAllItemsEvaluablesByAsignatura(
				alum.getId(), asignatura.getId());
	}

	/**
	 * Calcula la nota para una asignatura
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param criterios
	 * @param nota
	 * @return
	 */
	private double calcularNotaEvaluacion(List<Double> medias,
			List<Integer> contadores, Map<String, Integer> criterios) {
		double mediaExamen, mediaTrabajo, mediaActividad;
		if (contadores.get(4) == 0) {
			mediaExamen = 0.0;
		} else {
			mediaExamen = medias.get(4) / contadores.get(4);
		}
		if (contadores.get(7) == 0) {
			mediaTrabajo = 0.0;
		} else {
			mediaTrabajo = medias.get(7) / contadores.get(7);
		}
		if (contadores.get(1) == 0) {
			mediaActividad = 0.0;
		} else {
			mediaActividad = medias.get(1) / contadores.get(1);
		}
		double notaTotal = 0.0;

		Set<Entry<String, Integer>> conjuntoPares = criterios.entrySet();
		for (Entry<String, Integer> entry : conjuntoPares) {
			if (entry.getKey().equals("Examen")) {
				notaTotal += mediaExamen * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Trabajo")) {
				notaTotal += mediaTrabajo * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Actividad")) {
				notaTotal += mediaActividad * entry.getValue() / 100;
			}
		}
		
		return notaTotal;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public List<PadreMadreOTutor> getTutores(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		Alumno alum = findOne(alumnoId);
		Assert.notNull(alum);
		return Lists.newArrayList(alum.getPadresMadresOTutores());
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void establecerItemEvaluacion(Date fecha, Alumno alumn,
			Materia asig, String tipoNota, int calificacion) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");

		ItemEvaluable item = servicio.create();
		if (calificacion < 5) {
			item.setTitulo(tipoNota + ", No trabaja");
		} else {
			item.setTitulo(tipoNota + ", Si trabaja");
		}

		item.setFecha(fecha);
		item.setMateria(asig);
		item.setCalificacion(calificacion);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<Profesor> getProfesores(Alumno alum) {
		Set<Profesor> profesores = Sets.newHashSet();
		alum.getCursos().stream().filter(curso->{
			return curso.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(curso->{ return curso.getProfesor() })
		return profesores;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnosImportados
	 * @throws ParseException
	 */
	public void guardarAlumnosImportados(List<String[]> alumnosImportados)
			throws ParseException {
		for (String[] alumnoParseado : alumnosImportados) {
			Alumno a = this.create(alumnoParseado);

			for (Alumno temp : cursoService.getAlumnosEnCurso(a.getCurso()
					.getId())) {
				if (temp.getNombre().trim().compareTo(a.getNombre().trim()) == 0
						&& temp.getApellidos().trim()
								.compareTo(a.getApellidos().trim()) == 0
						&& new Date(temp.getFechaNacimiento().getTime())
								.equals(a.getFechaNacimiento())) {
					throw new IllegalArgumentException("El alumno "
							+ temp.getNombre() + temp.getApellidos()
							+ " ya está registrado en el sistema");
				}
			}
			alumnoRepositorio.save(a);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoParseado
	 * @return
	 * @throws ParseException
	 */
	private Alumno create(String[] alumnoParseado) throws ParseException {
		Alumno a = create();
		a.setNombre(alumnoParseado[0].trim());
		a.setApellidos(alumnoParseado[1].trim());
		String curso = alumnoParseado[2].trim();
		int nivel = Integer.valueOf(curso.split(" ")[0]);
		String nivelE = curso.split(" ")[1];
		char iden = curso.split(" ")[2].charAt(0);
		Curso c = cursoService.find(nivel, nivelE, iden);
		Assert.notNull(c);
		Assert.isTrue(profesorService.getCursosImparteDocencia().contains(c));
		a.setCurso(c);
		SimpleDateFormat sp = new SimpleDateFormat("mm/dd/yyyy");
		a.setFechaNacimiento(sp.parse(alumnoParseado[3]));
		try {
			a.setPendiente(alumnoParseado[4].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setPendiente(" ");
		}
		try {
			a.setRepiteCurso(alumnoParseado[5].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setRepiteCurso(" ");
		}
		return a;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void crearItemEvaluacion(Date fecha, Alumno alumn, Asignatura asig,
			String tipoNota, String titulo) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");
		ItemEvaluable item = servicio.create();
		item.setTitulo(titulo);
		item.setFecha(fecha);
		item.setAsignatura(asig);
		item.setCalificacion(0);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param nombre
	 * @param apellidos
	 * @param c
	 * @param fechaNacimiento
	 * @return
	 */
	public Alumno findAlumno(String nombre, String apellidos, Curso c,
			Date fechaNacimiento) {
		Alumno alumnoBuscado = null;
		PadreMadreOTutor tutor = tutorService.findPrincipal();
		Assert.notNull(tutor);
		Assert.isTrue(tutor.isIdentidadConfirmada());
		Collection<Alumno> primerFiltro = alumnoRepositorio
				.findByCursoYFechaNacimiento(c.getId(), fechaNacimiento);
		for (Alumno a : primerFiltro) {
			if (a.getApellidos().equals(apellidos)
					&& a.getApellidos().compareTo(apellidos) == 0
					&& a.getNombre().equals(nombre)
					&& a.getNombre().compareTo(nombre) == 0
					&& !a.getPadresMadresOTutores().contains(tutor)
					&& a.getPadresMadresOTutores().size() <= 2) {
				alumnoBuscado = a;
			}
		}
		return alumnoBuscado;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param tutor
	 */
	public void vincularConProfesor(Alumno alum, PadreMadreOTutor tutor) {
		Assert.notNull(tutor);
		Assert.isTrue(!alum.getPadresMadresOTutores().contains(tutor));
		alum.addPadreMadreOTutor(tutor);
		tutor.addTutorando(alum);
		save(alum);
		tutorService.save(tutor);
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public Collection<FaltaDeAsistencia> getFaltasAlumno(Alumno alum) {
		List<FaltaDeAsistencia> faltas = Lists.newArrayList();
		Collection<ItemEvaluable> items = alumnoRepositorio
				.getAllItemsEvaluables(alum.getId());
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				faltas.add(falta);
			}
		}
		return faltas;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:36.062
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:36.062
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:36.062
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:36.062
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:36.077
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-18 00:12:48.247
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * AlumnoService.java
 * appEducacional
 * 27/01/2014 09:06:00
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

/**
 * imports
 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.Materia;
import com.app.domain.model.types.NotaPorEvaluacion;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Retraso;
import com.app.domain.repositories.AlumnoRepository;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Transactional
@Service
/**
 * @author David Romero Alcaide
 *
 */
public class AlumnoService {

	/**
	 * Constructor
	 */
	public AlumnoService() {
		super();

	}
	
	/**
	 * Log
	 */
	private static final Logger LOGGER = Logger
			.getLogger(AlumnoService.class);

	@Autowired
	/**
	 * Repositorio para interactuar con la base de datos
	 */
	private AlumnoRepository alumnoRepositorio;

	// Servicios gestionados

	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoService cursoService;
	
	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	/**
	 * Servicio para el item evaluable falta de asistencia
	 */
	private RetrasoService retrasoService;

	@Autowired
	/**
	 * 
	 */
	private ProfesorService profesorService;

	@Autowired
	/**
	 * 
	 */
	private NotaPorEvaluacionService notaPorEvaluacionService;

	@Autowired
	/**
	 * 
	 */
	private EvaluacionService evaluacionService;

	@Autowired
	/**
	 * 
	 */
	private PadreMadreOTutorService tutorService;

	// Application context
	@Autowired
	/**
	 * 
	 */
	private ApplicationContext appContext;

	// Métodos CRUD

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Alumno create() {
		Alumno a = new Alumno();
		return a;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> findAll() {
		List<Alumno> ite;
		ite = alumnoRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public Alumno findOne(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		return alumnoRepositorio.findOne(alumnoId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void save(Alumno alumno) {
		Assert.notNull(alumno);
		alumnoRepositorio.save(alumno);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void delete(Alumno alumno) {
		Assert.notNull(alumno);
		Assert.isTrue(alumno.getId() > 0);
		alumnoRepositorio.delete(alumno);
	}

	// Otros métodos de negocio

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @param alumno
	 */
	public void establecerRetraso(Materia a, Alumno alumno) {
		Assert.notNull(a, "pasarLista.asignatura");
		Assert.notNull(alumno, "pasarLista.idAlumno");
		String except = "pasarLista.cursoAlum";
		Assert.isTrue(a.getCurso().getAlumnos().contains(alumno),
				except);
		Assert.isTrue(!(existeRetrasoEnAsignaturaParaHoy(a, alumno)),
				"pasarLista.yaExiste");

		Assert.isTrue(a.getProfesor().isIdentidadConfirmada(),
				except);

		/*
		 *  Es necesario que este creado el dia
		 */

		ItemEvaluable item = retrasoService.create();

		item.setFecha(new Date(System.currentTimeMillis()));
		item.setMateria(a);
		item.setCalificacion(0.0);
		item.setEvaluacion(evaluacionService.findByDate(new Date(System
				.currentTimeMillis())));
		retrasoService.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 * @param a
	 * @param asig
	 */
	private boolean existeRetrasoEnAsignaturaParaHoy(Materia asig, Alumno a) {
		boolean result = false;
		Assert.isTrue(asig.getProfesor().isIdentidadConfirmada());
		for (ItemEvaluable items : a.getItemsEvaluables()) {
			if (items instanceof Retraso && items.getMateria().equals(asig)) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Obtener los items evaluables de un alumno
	 * 
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<ItemEvaluable> obtenerItemsAlumno(Alumno alum) {
		return Lists.newArrayList(alumnoRepositorio.getAllItemsEvaluables(alum
				.getId()));
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<NotaPorEvaluacion> obtenerNotasPorEvaluacion(Alumno alum,Materia asignatura) {
		Map<Class<? extends ItemEvaluable>, Integer> criterios = asignatura.getCriteriosDeEvaluacion();
		Assert.isTrue(criterios.size() > 0);
		List<NotaPorEvaluacion> notas = Lists.newArrayList();
		List<List<Integer>> contadores = new ArrayList<List<Integer>>();
		List<List<Double>> medias = new ArrayList<List<Double>>();
		iniciarContadores(medias, contadores);
		calcularMediasDeNotas(alum, asignatura, contadores, medias);
		List<NotaPorEvaluacion> notasDelAlumnoEnAsignatura = notaPorEvaluacionService
				.getNotasPorEvaluacion(alum, asignatura);
		Assert.isTrue(notasDelAlumnoEnAsignatura.size() == 3);
		double nota = -1;
		
		nota = calcularNotaEvaluacion(medias.get(0), contadores.get(0), criterios);
		NotaPorEvaluacion nota1 = notasDelAlumnoEnAsignatura.get(0);
		nota1.setNotaFinal(nota);
		nota1.setAlumno(alum);
		nota1.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota1);

		this.save(alum);
		notas.add(nota1);

		nota = calcularNotaEvaluacion(medias.get(1), contadores.get(1), criterios);
		NotaPorEvaluacion nota2 = notasDelAlumnoEnAsignatura.get(1);
		nota2.setNotaFinal(nota);
		nota2.setAlumno(alum);
		nota2.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota2);

		this.save(alum);
		notas.add(nota2);
		nota = calcularNotaEvaluacion(medias.get(2), contadores.get(2), criterios);
		NotaPorEvaluacion nota3 = notasDelAlumnoEnAsignatura.get(2);
		nota3.setNotaFinal(nota);
		nota3.setAlumno(alum);
		nota3.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota3);

		this.save(alum);
		notas.add(nota3);
		return notas;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @param contadores
	 * @param medias
	 */
	private void calcularMediasDeNotas(Alumno alum, Materia
			asignatura,
			List<List<Integer>> contadores, List<List<Double>> medias) {
		for (ItemEvaluable item : obtenerItemsAlumnoAsignatura(alum, asignatura)) {
			calcularMediaItemsEvaluacion(medias, contadores, item, 0);
			calcularMediaItemsEvaluacion(medias, contadores, item, 1);
			calcularMediaItemsEvaluacion(medias, contadores, item, 2);
		}
	}

	/**
	 * Inicia los contadores y las sumas a 0
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 */
	private void iniciarContadores(List<List<Double>> medias,
			List<List<Integer>> contadores) {
		for (int i = 0; i < 3; i++) {
			medias.add(i, new ArrayList<Double>());
			contadores.add(i, new ArrayList<Integer>());
			for (int ii = 0; ii < 8; ii++) {
				medias.get(i).add(ii, 0.0);
				contadores.get(i).add(ii, 0);
			}
		}
	}

	/**
	 * Obtiene las medias de los items
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param item
	 * @param evaluacion
	 */
	private void calcularMediaItemsEvaluacion(List<List<Double>> medias,
			List<List<Integer>> contadores, ItemEvaluable item, int evaluacion) {
		Assert.notNull(item.getEvaluacion());
		String pack = "com.app.domain.model.types.itemsevaluables.";
		if (item.getEvaluacion().getIndicador() == (evaluacion + 1)) {
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Examen") == 0) {
				Double notaVieja = medias.get(evaluacion).get(4);
				medias.get(evaluacion).set(4,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(4);
				contadores.get(evaluacion).set(4, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Actividad") == 0) {
				Double notaVieja = medias.get(evaluacion).get(1);
				medias.get(evaluacion).set(1,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(1);
				contadores.get(evaluacion).set(1, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Trabajo") == 0) {
				Double notaVieja = medias.get(evaluacion).get(7);
				medias.get(evaluacion).set(7,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(7);
				contadores.get(evaluacion).set(7, contAntiguo + 1);
			}
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @return
	 */
	public Collection<ItemEvaluable> obtenerItemsAlumnoAsignatura(Alumno alum,
			Asignatura asignatura) {
		Assert.notNull(asignatura);
		Assert.notNull(alum);
		return alumnoRepositorio.getAllItemsEvaluablesByAsignatura(
				alum.getId(), asignatura.getId());
	}

	/**
	 * Calcula la nota para una asignatura
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param criterios
	 * @param nota
	 * @return
	 */
	private double calcularNotaEvaluacion(List<Double> medias,
			List<Integer> contadores, Map<String, Integer> criterios) {
		double mediaExamen, mediaTrabajo, mediaActividad;
		if (contadores.get(4) == 0) {
			mediaExamen = 0.0;
		} else {
			mediaExamen = medias.get(4) / contadores.get(4);
		}
		if (contadores.get(7) == 0) {
			mediaTrabajo = 0.0;
		} else {
			mediaTrabajo = medias.get(7) / contadores.get(7);
		}
		if (contadores.get(1) == 0) {
			mediaActividad = 0.0;
		} else {
			mediaActividad = medias.get(1) / contadores.get(1);
		}
		double notaTotal = 0.0;

		Set<Entry<String, Integer>> conjuntoPares = criterios.entrySet();
		for (Entry<String, Integer> entry : conjuntoPares) {
			if (entry.getKey().equals("Examen")) {
				notaTotal += mediaExamen * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Trabajo")) {
				notaTotal += mediaTrabajo * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Actividad")) {
				notaTotal += mediaActividad * entry.getValue() / 100;
			}
		}
		
		return notaTotal;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public List<PadreMadreOTutor> getTutores(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		Alumno alum = findOne(alumnoId);
		Assert.notNull(alum);
		return Lists.newArrayList(alum.getPadresMadresOTutores());
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void establecerItemEvaluacion(Date fecha, Alumno alumn,
			Materia asig, String tipoNota, int calificacion) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");

		ItemEvaluable item = servicio.create();
		if (calificacion < 5) {
			item.setTitulo(tipoNota + ", No trabaja");
		} else {
			item.setTitulo(tipoNota + ", Si trabaja");
		}

		item.setFecha(fecha);
		item.setMateria(asig);
		item.setCalificacion(calificacion);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<Profesor> getProfesores(Alumno alum) {
		Set<Profesor> profesores = Sets.newHashSet();
		alum.getCursos().stream().filter(curso->{
			return curso.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(curso->{ return curso.getProfesor() }).collect(Collectors.toS)
		return profesores;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnosImportados
	 * @throws ParseException
	 */
	public void guardarAlumnosImportados(List<String[]> alumnosImportados)
			throws ParseException {
		for (String[] alumnoParseado : alumnosImportados) {
			Alumno a = this.create(alumnoParseado);

			for (Alumno temp : cursoService.getAlumnosEnCurso(a.getCurso()
					.getId())) {
				if (temp.getNombre().trim().compareTo(a.getNombre().trim()) == 0
						&& temp.getApellidos().trim()
								.compareTo(a.getApellidos().trim()) == 0
						&& new Date(temp.getFechaNacimiento().getTime())
								.equals(a.getFechaNacimiento())) {
					throw new IllegalArgumentException("El alumno "
							+ temp.getNombre() + temp.getApellidos()
							+ " ya está registrado en el sistema");
				}
			}
			alumnoRepositorio.save(a);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoParseado
	 * @return
	 * @throws ParseException
	 */
	private Alumno create(String[] alumnoParseado) throws ParseException {
		Alumno a = create();
		a.setNombre(alumnoParseado[0].trim());
		a.setApellidos(alumnoParseado[1].trim());
		String curso = alumnoParseado[2].trim();
		int nivel = Integer.valueOf(curso.split(" ")[0]);
		String nivelE = curso.split(" ")[1];
		char iden = curso.split(" ")[2].charAt(0);
		Curso c = cursoService.find(nivel, nivelE, iden);
		Assert.notNull(c);
		Assert.isTrue(profesorService.getCursosImparteDocencia().contains(c));
		a.setCurso(c);
		SimpleDateFormat sp = new SimpleDateFormat("mm/dd/yyyy");
		a.setFechaNacimiento(sp.parse(alumnoParseado[3]));
		try {
			a.setPendiente(alumnoParseado[4].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setPendiente(" ");
		}
		try {
			a.setRepiteCurso(alumnoParseado[5].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setRepiteCurso(" ");
		}
		return a;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void crearItemEvaluacion(Date fecha, Alumno alumn, Asignatura asig,
			String tipoNota, String titulo) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");
		ItemEvaluable item = servicio.create();
		item.setTitulo(titulo);
		item.setFecha(fecha);
		item.setAsignatura(asig);
		item.setCalificacion(0);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param nombre
	 * @param apellidos
	 * @param c
	 * @param fechaNacimiento
	 * @return
	 */
	public Alumno findAlumno(String nombre, String apellidos, Curso c,
			Date fechaNacimiento) {
		Alumno alumnoBuscado = null;
		PadreMadreOTutor tutor = tutorService.findPrincipal();
		Assert.notNull(tutor);
		Assert.isTrue(tutor.isIdentidadConfirmada());
		Collection<Alumno> primerFiltro = alumnoRepositorio
				.findByCursoYFechaNacimiento(c.getId(), fechaNacimiento);
		for (Alumno a : primerFiltro) {
			if (a.getApellidos().equals(apellidos)
					&& a.getApellidos().compareTo(apellidos) == 0
					&& a.getNombre().equals(nombre)
					&& a.getNombre().compareTo(nombre) == 0
					&& !a.getPadresMadresOTutores().contains(tutor)
					&& a.getPadresMadresOTutores().size() <= 2) {
				alumnoBuscado = a;
			}
		}
		return alumnoBuscado;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param tutor
	 */
	public void vincularConProfesor(Alumno alum, PadreMadreOTutor tutor) {
		Assert.notNull(tutor);
		Assert.isTrue(!alum.getPadresMadresOTutores().contains(tutor));
		alum.addPadreMadreOTutor(tutor);
		tutor.addTutorando(alum);
		save(alum);
		tutorService.save(tutor);
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public Collection<FaltaDeAsistencia> getFaltasAlumno(Alumno alum) {
		List<FaltaDeAsistencia> faltas = Lists.newArrayList();
		Collection<ItemEvaluable> items = alumnoRepositorio
				.getAllItemsEvaluables(alum.getId());
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				faltas.add(falta);
			}
		}
		return faltas;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:48.263
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:48.263
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:48.263
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:48.263
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:48.263
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-18 00:12:49.337
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * AlumnoService.java
 * appEducacional
 * 27/01/2014 09:06:00
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

/**
 * imports
 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.Materia;
import com.app.domain.model.types.NotaPorEvaluacion;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Retraso;
import com.app.domain.repositories.AlumnoRepository;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Transactional
@Service
/**
 * @author David Romero Alcaide
 *
 */
public class AlumnoService {

	/**
	 * Constructor
	 */
	public AlumnoService() {
		super();

	}
	
	/**
	 * Log
	 */
	private static final Logger LOGGER = Logger
			.getLogger(AlumnoService.class);

	@Autowired
	/**
	 * Repositorio para interactuar con la base de datos
	 */
	private AlumnoRepository alumnoRepositorio;

	// Servicios gestionados

	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoService cursoService;
	
	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	/**
	 * Servicio para el item evaluable falta de asistencia
	 */
	private RetrasoService retrasoService;

	@Autowired
	/**
	 * 
	 */
	private ProfesorService profesorService;

	@Autowired
	/**
	 * 
	 */
	private NotaPorEvaluacionService notaPorEvaluacionService;

	@Autowired
	/**
	 * 
	 */
	private EvaluacionService evaluacionService;

	@Autowired
	/**
	 * 
	 */
	private PadreMadreOTutorService tutorService;

	// Application context
	@Autowired
	/**
	 * 
	 */
	private ApplicationContext appContext;

	// Métodos CRUD

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Alumno create() {
		Alumno a = new Alumno();
		return a;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> findAll() {
		List<Alumno> ite;
		ite = alumnoRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public Alumno findOne(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		return alumnoRepositorio.findOne(alumnoId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void save(Alumno alumno) {
		Assert.notNull(alumno);
		alumnoRepositorio.save(alumno);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void delete(Alumno alumno) {
		Assert.notNull(alumno);
		Assert.isTrue(alumno.getId() > 0);
		alumnoRepositorio.delete(alumno);
	}

	// Otros métodos de negocio

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @param alumno
	 */
	public void establecerRetraso(Materia a, Alumno alumno) {
		Assert.notNull(a, "pasarLista.asignatura");
		Assert.notNull(alumno, "pasarLista.idAlumno");
		String except = "pasarLista.cursoAlum";
		Assert.isTrue(a.getCurso().getAlumnos().contains(alumno),
				except);
		Assert.isTrue(!(existeRetrasoEnAsignaturaParaHoy(a, alumno)),
				"pasarLista.yaExiste");

		Assert.isTrue(a.getProfesor().isIdentidadConfirmada(),
				except);

		/*
		 *  Es necesario que este creado el dia
		 */

		ItemEvaluable item = retrasoService.create();

		item.setFecha(new Date(System.currentTimeMillis()));
		item.setMateria(a);
		item.setCalificacion(0.0);
		item.setEvaluacion(evaluacionService.findByDate(new Date(System
				.currentTimeMillis())));
		retrasoService.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 * @param a
	 * @param asig
	 */
	private boolean existeRetrasoEnAsignaturaParaHoy(Materia asig, Alumno a) {
		boolean result = false;
		Assert.isTrue(asig.getProfesor().isIdentidadConfirmada());
		for (ItemEvaluable items : a.getItemsEvaluables()) {
			if (items instanceof Retraso && items.getMateria().equals(asig)) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Obtener los items evaluables de un alumno
	 * 
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<ItemEvaluable> obtenerItemsAlumno(Alumno alum) {
		return Lists.newArrayList(alumnoRepositorio.getAllItemsEvaluables(alum
				.getId()));
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<NotaPorEvaluacion> obtenerNotasPorEvaluacion(Alumno alum,Materia asignatura) {
		Map<Class<? extends ItemEvaluable>, Integer> criterios = asignatura.getCriteriosDeEvaluacion();
		Assert.isTrue(criterios.size() > 0);
		List<NotaPorEvaluacion> notas = Lists.newArrayList();
		List<List<Integer>> contadores = new ArrayList<List<Integer>>();
		List<List<Double>> medias = new ArrayList<List<Double>>();
		iniciarContadores(medias, contadores);
		calcularMediasDeNotas(alum, asignatura, contadores, medias);
		List<NotaPorEvaluacion> notasDelAlumnoEnAsignatura = notaPorEvaluacionService
				.getNotasPorEvaluacion(alum, asignatura);
		Assert.isTrue(notasDelAlumnoEnAsignatura.size() == 3);
		double nota = -1;
		
		nota = calcularNotaEvaluacion(medias.get(0), contadores.get(0), criterios);
		NotaPorEvaluacion nota1 = notasDelAlumnoEnAsignatura.get(0);
		nota1.setNotaFinal(nota);
		nota1.setAlumno(alum);
		nota1.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota1);

		this.save(alum);
		notas.add(nota1);

		nota = calcularNotaEvaluacion(medias.get(1), contadores.get(1), criterios);
		NotaPorEvaluacion nota2 = notasDelAlumnoEnAsignatura.get(1);
		nota2.setNotaFinal(nota);
		nota2.setAlumno(alum);
		nota2.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota2);

		this.save(alum);
		notas.add(nota2);
		nota = calcularNotaEvaluacion(medias.get(2), contadores.get(2), criterios);
		NotaPorEvaluacion nota3 = notasDelAlumnoEnAsignatura.get(2);
		nota3.setNotaFinal(nota);
		nota3.setAlumno(alum);
		nota3.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota3);

		this.save(alum);
		notas.add(nota3);
		return notas;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @param contadores
	 * @param medias
	 */
	private void calcularMediasDeNotas(Alumno alum, Materia
			asignatura,
			List<List<Integer>> contadores, List<List<Double>> medias) {
		for (ItemEvaluable item : obtenerItemsAlumnoAsignatura(alum, asignatura)) {
			calcularMediaItemsEvaluacion(medias, contadores, item, 0);
			calcularMediaItemsEvaluacion(medias, contadores, item, 1);
			calcularMediaItemsEvaluacion(medias, contadores, item, 2);
		}
	}

	/**
	 * Inicia los contadores y las sumas a 0
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 */
	private void iniciarContadores(List<List<Double>> medias,
			List<List<Integer>> contadores) {
		for (int i = 0; i < 3; i++) {
			medias.add(i, new ArrayList<Double>());
			contadores.add(i, new ArrayList<Integer>());
			for (int ii = 0; ii < 8; ii++) {
				medias.get(i).add(ii, 0.0);
				contadores.get(i).add(ii, 0);
			}
		}
	}

	/**
	 * Obtiene las medias de los items
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param item
	 * @param evaluacion
	 */
	private void calcularMediaItemsEvaluacion(List<List<Double>> medias,
			List<List<Integer>> contadores, ItemEvaluable item, int evaluacion) {
		Assert.notNull(item.getEvaluacion());
		String pack = "com.app.domain.model.types.itemsevaluables.";
		if (item.getEvaluacion().getIndicador() == (evaluacion + 1)) {
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Examen") == 0) {
				Double notaVieja = medias.get(evaluacion).get(4);
				medias.get(evaluacion).set(4,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(4);
				contadores.get(evaluacion).set(4, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Actividad") == 0) {
				Double notaVieja = medias.get(evaluacion).get(1);
				medias.get(evaluacion).set(1,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(1);
				contadores.get(evaluacion).set(1, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Trabajo") == 0) {
				Double notaVieja = medias.get(evaluacion).get(7);
				medias.get(evaluacion).set(7,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(7);
				contadores.get(evaluacion).set(7, contAntiguo + 1);
			}
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @return
	 */
	public Collection<ItemEvaluable> obtenerItemsAlumnoAsignatura(Alumno alum,
			Asignatura asignatura) {
		Assert.notNull(asignatura);
		Assert.notNull(alum);
		return alumnoRepositorio.getAllItemsEvaluablesByAsignatura(
				alum.getId(), asignatura.getId());
	}

	/**
	 * Calcula la nota para una asignatura
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param criterios
	 * @param nota
	 * @return
	 */
	private double calcularNotaEvaluacion(List<Double> medias,
			List<Integer> contadores, Map<String, Integer> criterios) {
		double mediaExamen, mediaTrabajo, mediaActividad;
		if (contadores.get(4) == 0) {
			mediaExamen = 0.0;
		} else {
			mediaExamen = medias.get(4) / contadores.get(4);
		}
		if (contadores.get(7) == 0) {
			mediaTrabajo = 0.0;
		} else {
			mediaTrabajo = medias.get(7) / contadores.get(7);
		}
		if (contadores.get(1) == 0) {
			mediaActividad = 0.0;
		} else {
			mediaActividad = medias.get(1) / contadores.get(1);
		}
		double notaTotal = 0.0;

		Set<Entry<String, Integer>> conjuntoPares = criterios.entrySet();
		for (Entry<String, Integer> entry : conjuntoPares) {
			if (entry.getKey().equals("Examen")) {
				notaTotal += mediaExamen * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Trabajo")) {
				notaTotal += mediaTrabajo * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Actividad")) {
				notaTotal += mediaActividad * entry.getValue() / 100;
			}
		}
		
		return notaTotal;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public List<PadreMadreOTutor> getTutores(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		Alumno alum = findOne(alumnoId);
		Assert.notNull(alum);
		return Lists.newArrayList(alum.getPadresMadresOTutores());
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void establecerItemEvaluacion(Date fecha, Alumno alumn,
			Materia asig, String tipoNota, int calificacion) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");

		ItemEvaluable item = servicio.create();
		if (calificacion < 5) {
			item.setTitulo(tipoNota + ", No trabaja");
		} else {
			item.setTitulo(tipoNota + ", Si trabaja");
		}

		item.setFecha(fecha);
		item.setMateria(asig);
		item.setCalificacion(calificacion);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<Profesor> getProfesores(Alumno alum) {
		Set<Profesor> profesores = Sets.newHashSet();
		alum.getCursos().stream().filter(curso->{
			return curso.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(curso->{ return curso.getProfesor() }).collect(Collectors.toSet())
		return profesores;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnosImportados
	 * @throws ParseException
	 */
	public void guardarAlumnosImportados(List<String[]> alumnosImportados)
			throws ParseException {
		for (String[] alumnoParseado : alumnosImportados) {
			Alumno a = this.create(alumnoParseado);

			for (Alumno temp : cursoService.getAlumnosEnCurso(a.getCurso()
					.getId())) {
				if (temp.getNombre().trim().compareTo(a.getNombre().trim()) == 0
						&& temp.getApellidos().trim()
								.compareTo(a.getApellidos().trim()) == 0
						&& new Date(temp.getFechaNacimiento().getTime())
								.equals(a.getFechaNacimiento())) {
					throw new IllegalArgumentException("El alumno "
							+ temp.getNombre() + temp.getApellidos()
							+ " ya está registrado en el sistema");
				}
			}
			alumnoRepositorio.save(a);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoParseado
	 * @return
	 * @throws ParseException
	 */
	private Alumno create(String[] alumnoParseado) throws ParseException {
		Alumno a = create();
		a.setNombre(alumnoParseado[0].trim());
		a.setApellidos(alumnoParseado[1].trim());
		String curso = alumnoParseado[2].trim();
		int nivel = Integer.valueOf(curso.split(" ")[0]);
		String nivelE = curso.split(" ")[1];
		char iden = curso.split(" ")[2].charAt(0);
		Curso c = cursoService.find(nivel, nivelE, iden);
		Assert.notNull(c);
		Assert.isTrue(profesorService.getCursosImparteDocencia().contains(c));
		a.setCurso(c);
		SimpleDateFormat sp = new SimpleDateFormat("mm/dd/yyyy");
		a.setFechaNacimiento(sp.parse(alumnoParseado[3]));
		try {
			a.setPendiente(alumnoParseado[4].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setPendiente(" ");
		}
		try {
			a.setRepiteCurso(alumnoParseado[5].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setRepiteCurso(" ");
		}
		return a;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void crearItemEvaluacion(Date fecha, Alumno alumn, Asignatura asig,
			String tipoNota, String titulo) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");
		ItemEvaluable item = servicio.create();
		item.setTitulo(titulo);
		item.setFecha(fecha);
		item.setAsignatura(asig);
		item.setCalificacion(0);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param nombre
	 * @param apellidos
	 * @param c
	 * @param fechaNacimiento
	 * @return
	 */
	public Alumno findAlumno(String nombre, String apellidos, Curso c,
			Date fechaNacimiento) {
		Alumno alumnoBuscado = null;
		PadreMadreOTutor tutor = tutorService.findPrincipal();
		Assert.notNull(tutor);
		Assert.isTrue(tutor.isIdentidadConfirmada());
		Collection<Alumno> primerFiltro = alumnoRepositorio
				.findByCursoYFechaNacimiento(c.getId(), fechaNacimiento);
		for (Alumno a : primerFiltro) {
			if (a.getApellidos().equals(apellidos)
					&& a.getApellidos().compareTo(apellidos) == 0
					&& a.getNombre().equals(nombre)
					&& a.getNombre().compareTo(nombre) == 0
					&& !a.getPadresMadresOTutores().contains(tutor)
					&& a.getPadresMadresOTutores().size() <= 2) {
				alumnoBuscado = a;
			}
		}
		return alumnoBuscado;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param tutor
	 */
	public void vincularConProfesor(Alumno alum, PadreMadreOTutor tutor) {
		Assert.notNull(tutor);
		Assert.isTrue(!alum.getPadresMadresOTutores().contains(tutor));
		alum.addPadreMadreOTutor(tutor);
		tutor.addTutorando(alum);
		save(alum);
		tutorService.save(tutor);
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public Collection<FaltaDeAsistencia> getFaltasAlumno(Alumno alum) {
		List<FaltaDeAsistencia> faltas = Lists.newArrayList();
		Collection<ItemEvaluable> items = alumnoRepositorio
				.getAllItemsEvaluables(alum.getId());
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				faltas.add(falta);
			}
		}
		return faltas;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:49.337
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:49.337
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:49.337
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:49.337
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:49.337
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:51.105
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:51.105
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-18 00:12:52.933
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * AlumnoService.java
 * appEducacional
 * 27/01/2014 09:06:00
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

/**
 * imports
 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.Materia;
import com.app.domain.model.types.NotaPorEvaluacion;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Retraso;
import com.app.domain.repositories.AlumnoRepository;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Transactional
@Service
/**
 * @author David Romero Alcaide
 *
 */
public class AlumnoService {

	/**
	 * Constructor
	 */
	public AlumnoService() {
		super();

	}
	
	/**
	 * Log
	 */
	private static final Logger LOGGER = Logger
			.getLogger(AlumnoService.class);

	@Autowired
	/**
	 * Repositorio para interactuar con la base de datos
	 */
	private AlumnoRepository alumnoRepositorio;

	// Servicios gestionados

	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoService cursoService;
	
	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	/**
	 * Servicio para el item evaluable falta de asistencia
	 */
	private RetrasoService retrasoService;

	@Autowired
	/**
	 * 
	 */
	private ProfesorService profesorService;

	@Autowired
	/**
	 * 
	 */
	private NotaPorEvaluacionService notaPorEvaluacionService;

	@Autowired
	/**
	 * 
	 */
	private EvaluacionService evaluacionService;

	@Autowired
	/**
	 * 
	 */
	private PadreMadreOTutorService tutorService;

	// Application context
	@Autowired
	/**
	 * 
	 */
	private ApplicationContext appContext;

	// Métodos CRUD

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Alumno create() {
		Alumno a = new Alumno();
		return a;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> findAll() {
		List<Alumno> ite;
		ite = alumnoRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public Alumno findOne(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		return alumnoRepositorio.findOne(alumnoId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void save(Alumno alumno) {
		Assert.notNull(alumno);
		alumnoRepositorio.save(alumno);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void delete(Alumno alumno) {
		Assert.notNull(alumno);
		Assert.isTrue(alumno.getId() > 0);
		alumnoRepositorio.delete(alumno);
	}

	// Otros métodos de negocio

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @param alumno
	 */
	public void establecerRetraso(Materia a, Alumno alumno) {
		Assert.notNull(a, "pasarLista.asignatura");
		Assert.notNull(alumno, "pasarLista.idAlumno");
		String except = "pasarLista.cursoAlum";
		Assert.isTrue(a.getCurso().getAlumnos().contains(alumno),
				except);
		Assert.isTrue(!(existeRetrasoEnAsignaturaParaHoy(a, alumno)),
				"pasarLista.yaExiste");

		Assert.isTrue(a.getProfesor().isIdentidadConfirmada(),
				except);

		/*
		 *  Es necesario que este creado el dia
		 */

		ItemEvaluable item = retrasoService.create();

		item.setFecha(new Date(System.currentTimeMillis()));
		item.setMateria(a);
		item.setCalificacion(0.0);
		item.setEvaluacion(evaluacionService.findByDate(new Date(System
				.currentTimeMillis())));
		retrasoService.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 * @param a
	 * @param asig
	 */
	private boolean existeRetrasoEnAsignaturaParaHoy(Materia asig, Alumno a) {
		boolean result = false;
		Assert.isTrue(asig.getProfesor().isIdentidadConfirmada());
		for (ItemEvaluable items : a.getItemsEvaluables()) {
			if (items instanceof Retraso && items.getMateria().equals(asig)) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Obtener los items evaluables de un alumno
	 * 
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<ItemEvaluable> obtenerItemsAlumno(Alumno alum) {
		return Lists.newArrayList(alumnoRepositorio.getAllItemsEvaluables(alum
				.getId()));
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<NotaPorEvaluacion> obtenerNotasPorEvaluacion(Alumno alum,Materia asignatura) {
		Map<Class<? extends ItemEvaluable>, Integer> criterios = asignatura.getCriteriosDeEvaluacion();
		Assert.isTrue(criterios.size() > 0);
		List<NotaPorEvaluacion> notas = Lists.newArrayList();
		List<List<Integer>> contadores = new ArrayList<List<Integer>>();
		List<List<Double>> medias = new ArrayList<List<Double>>();
		iniciarContadores(medias, contadores);
		calcularMediasDeNotas(alum, asignatura, contadores, medias);
		List<NotaPorEvaluacion> notasDelAlumnoEnAsignatura = notaPorEvaluacionService
				.getNotasPorEvaluacion(alum, asignatura);
		Assert.isTrue(notasDelAlumnoEnAsignatura.size() == 3);
		double nota = -1;
		
		nota = calcularNotaEvaluacion(medias.get(0), contadores.get(0), criterios);
		NotaPorEvaluacion nota1 = notasDelAlumnoEnAsignatura.get(0);
		nota1.setNotaFinal(nota);
		nota1.setAlumno(alum);
		nota1.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota1);

		this.save(alum);
		notas.add(nota1);

		nota = calcularNotaEvaluacion(medias.get(1), contadores.get(1), criterios);
		NotaPorEvaluacion nota2 = notasDelAlumnoEnAsignatura.get(1);
		nota2.setNotaFinal(nota);
		nota2.setAlumno(alum);
		nota2.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota2);

		this.save(alum);
		notas.add(nota2);
		nota = calcularNotaEvaluacion(medias.get(2), contadores.get(2), criterios);
		NotaPorEvaluacion nota3 = notasDelAlumnoEnAsignatura.get(2);
		nota3.setNotaFinal(nota);
		nota3.setAlumno(alum);
		nota3.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota3);

		this.save(alum);
		notas.add(nota3);
		return notas;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @param contadores
	 * @param medias
	 */
	private void calcularMediasDeNotas(Alumno alum, Materia
			asignatura,
			List<List<Integer>> contadores, List<List<Double>> medias) {
		for (ItemEvaluable item : obtenerItemsAlumnoAsignatura(alum, asignatura)) {
			calcularMediaItemsEvaluacion(medias, contadores, item, 0);
			calcularMediaItemsEvaluacion(medias, contadores, item, 1);
			calcularMediaItemsEvaluacion(medias, contadores, item, 2);
		}
	}

	/**
	 * Inicia los contadores y las sumas a 0
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 */
	private void iniciarContadores(List<List<Double>> medias,
			List<List<Integer>> contadores) {
		for (int i = 0; i < 3; i++) {
			medias.add(i, new ArrayList<Double>());
			contadores.add(i, new ArrayList<Integer>());
			for (int ii = 0; ii < 8; ii++) {
				medias.get(i).add(ii, 0.0);
				contadores.get(i).add(ii, 0);
			}
		}
	}

	/**
	 * Obtiene las medias de los items
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param item
	 * @param evaluacion
	 */
	private void calcularMediaItemsEvaluacion(List<List<Double>> medias,
			List<List<Integer>> contadores, ItemEvaluable item, int evaluacion) {
		Assert.notNull(item.getEvaluacion());
		String pack = "com.app.domain.model.types.itemsevaluables.";
		if (item.getEvaluacion().getIndicador() == (evaluacion + 1)) {
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Examen") == 0) {
				Double notaVieja = medias.get(evaluacion).get(4);
				medias.get(evaluacion).set(4,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(4);
				contadores.get(evaluacion).set(4, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Actividad") == 0) {
				Double notaVieja = medias.get(evaluacion).get(1);
				medias.get(evaluacion).set(1,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(1);
				contadores.get(evaluacion).set(1, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Trabajo") == 0) {
				Double notaVieja = medias.get(evaluacion).get(7);
				medias.get(evaluacion).set(7,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(7);
				contadores.get(evaluacion).set(7, contAntiguo + 1);
			}
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @return
	 */
	public Collection<ItemEvaluable> obtenerItemsAlumnoAsignatura(Alumno alum,
			Asignatura asignatura) {
		Assert.notNull(asignatura);
		Assert.notNull(alum);
		return alumnoRepositorio.getAllItemsEvaluablesByAsignatura(
				alum.getId(), asignatura.getId());
	}

	/**
	 * Calcula la nota para una asignatura
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param criterios
	 * @param nota
	 * @return
	 */
	private double calcularNotaEvaluacion(List<Double> medias,
			List<Integer> contadores, Map<String, Integer> criterios) {
		double mediaExamen, mediaTrabajo, mediaActividad;
		if (contadores.get(4) == 0) {
			mediaExamen = 0.0;
		} else {
			mediaExamen = medias.get(4) / contadores.get(4);
		}
		if (contadores.get(7) == 0) {
			mediaTrabajo = 0.0;
		} else {
			mediaTrabajo = medias.get(7) / contadores.get(7);
		}
		if (contadores.get(1) == 0) {
			mediaActividad = 0.0;
		} else {
			mediaActividad = medias.get(1) / contadores.get(1);
		}
		double notaTotal = 0.0;

		Set<Entry<String, Integer>> conjuntoPares = criterios.entrySet();
		for (Entry<String, Integer> entry : conjuntoPares) {
			if (entry.getKey().equals("Examen")) {
				notaTotal += mediaExamen * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Trabajo")) {
				notaTotal += mediaTrabajo * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Actividad")) {
				notaTotal += mediaActividad * entry.getValue() / 100;
			}
		}
		
		return notaTotal;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public List<PadreMadreOTutor> getTutores(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		Alumno alum = findOne(alumnoId);
		Assert.notNull(alum);
		return Lists.newArrayList(alum.getPadresMadresOTutores());
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void establecerItemEvaluacion(Date fecha, Alumno alumn,
			Materia asig, String tipoNota, int calificacion) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");

		ItemEvaluable item = servicio.create();
		if (calificacion < 5) {
			item.setTitulo(tipoNota + ", No trabaja");
		} else {
			item.setTitulo(tipoNota + ", Si trabaja");
		}

		item.setFecha(fecha);
		item.setMateria(asig);
		item.setCalificacion(calificacion);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<Profesor> getProfesores(Alumno alum) {
		Set<Profesor> profesores = Sets.newHashSet();
		return alum.getCursos().stream().filter(curso->{
			return curso.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(curso->{ return curso.getProfesor() }).collect(Collectors.toSet())
		return profesores;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnosImportados
	 * @throws ParseException
	 */
	public void guardarAlumnosImportados(List<String[]> alumnosImportados)
			throws ParseException {
		for (String[] alumnoParseado : alumnosImportados) {
			Alumno a = this.create(alumnoParseado);

			for (Alumno temp : cursoService.getAlumnosEnCurso(a.getCurso()
					.getId())) {
				if (temp.getNombre().trim().compareTo(a.getNombre().trim()) == 0
						&& temp.getApellidos().trim()
								.compareTo(a.getApellidos().trim()) == 0
						&& new Date(temp.getFechaNacimiento().getTime())
								.equals(a.getFechaNacimiento())) {
					throw new IllegalArgumentException("El alumno "
							+ temp.getNombre() + temp.getApellidos()
							+ " ya está registrado en el sistema");
				}
			}
			alumnoRepositorio.save(a);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoParseado
	 * @return
	 * @throws ParseException
	 */
	private Alumno create(String[] alumnoParseado) throws ParseException {
		Alumno a = create();
		a.setNombre(alumnoParseado[0].trim());
		a.setApellidos(alumnoParseado[1].trim());
		String curso = alumnoParseado[2].trim();
		int nivel = Integer.valueOf(curso.split(" ")[0]);
		String nivelE = curso.split(" ")[1];
		char iden = curso.split(" ")[2].charAt(0);
		Curso c = cursoService.find(nivel, nivelE, iden);
		Assert.notNull(c);
		Assert.isTrue(profesorService.getCursosImparteDocencia().contains(c));
		a.setCurso(c);
		SimpleDateFormat sp = new SimpleDateFormat("mm/dd/yyyy");
		a.setFechaNacimiento(sp.parse(alumnoParseado[3]));
		try {
			a.setPendiente(alumnoParseado[4].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setPendiente(" ");
		}
		try {
			a.setRepiteCurso(alumnoParseado[5].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setRepiteCurso(" ");
		}
		return a;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void crearItemEvaluacion(Date fecha, Alumno alumn, Asignatura asig,
			String tipoNota, String titulo) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");
		ItemEvaluable item = servicio.create();
		item.setTitulo(titulo);
		item.setFecha(fecha);
		item.setAsignatura(asig);
		item.setCalificacion(0);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param nombre
	 * @param apellidos
	 * @param c
	 * @param fechaNacimiento
	 * @return
	 */
	public Alumno findAlumno(String nombre, String apellidos, Curso c,
			Date fechaNacimiento) {
		Alumno alumnoBuscado = null;
		PadreMadreOTutor tutor = tutorService.findPrincipal();
		Assert.notNull(tutor);
		Assert.isTrue(tutor.isIdentidadConfirmada());
		Collection<Alumno> primerFiltro = alumnoRepositorio
				.findByCursoYFechaNacimiento(c.getId(), fechaNacimiento);
		for (Alumno a : primerFiltro) {
			if (a.getApellidos().equals(apellidos)
					&& a.getApellidos().compareTo(apellidos) == 0
					&& a.getNombre().equals(nombre)
					&& a.getNombre().compareTo(nombre) == 0
					&& !a.getPadresMadresOTutores().contains(tutor)
					&& a.getPadresMadresOTutores().size() <= 2) {
				alumnoBuscado = a;
			}
		}
		return alumnoBuscado;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param tutor
	 */
	public void vincularConProfesor(Alumno alum, PadreMadreOTutor tutor) {
		Assert.notNull(tutor);
		Assert.isTrue(!alum.getPadresMadresOTutores().contains(tutor));
		alum.addPadreMadreOTutor(tutor);
		tutor.addTutorando(alum);
		save(alum);
		tutorService.save(tutor);
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public Collection<FaltaDeAsistencia> getFaltasAlumno(Alumno alum) {
		List<FaltaDeAsistencia> faltas = Lists.newArrayList();
		Collection<ItemEvaluable> items = alumnoRepositorio
				.getAllItemsEvaluables(alum.getId());
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				faltas.add(falta);
			}
		}
		return faltas;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:52.933
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:52.933
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:52.933
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:52.933
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:52.933
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:53.011
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:53.011
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:56.140
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:56.140
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-04-18 00:12:57.015
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * AlumnoService.java
 * appEducacional
 * 27/01/2014 09:06:00
 * Copyright David Romero Alcaide
 * com.app.applicationservices.services
 */
package com.app.applicationservices.services;

/**
 * imports
 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.app.domain.model.types.Alumno;
import com.app.domain.model.types.Asignatura;
import com.app.domain.model.types.Curso;
import com.app.domain.model.types.ItemEvaluable;
import com.app.domain.model.types.Materia;
import com.app.domain.model.types.NotaPorEvaluacion;
import com.app.domain.model.types.PadreMadreOTutor;
import com.app.domain.model.types.Profesor;
import com.app.domain.model.types.itemsevaluables.FaltaDeAsistencia;
import com.app.domain.model.types.itemsevaluables.Retraso;
import com.app.domain.repositories.AlumnoRepository;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

@Transactional
@Service
/**
 * @author David Romero Alcaide
 *
 */
public class AlumnoService {

	/**
	 * Constructor
	 */
	public AlumnoService() {
		super();

	}
	
	/**
	 * Log
	 */
	private static final Logger LOGGER = Logger
			.getLogger(AlumnoService.class);

	@Autowired
	/**
	 * Repositorio para interactuar con la base de datos
	 */
	private AlumnoRepository alumnoRepositorio;

	// Servicios gestionados

	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoService cursoService;
	
	@Autowired
	/**
	 * Servicio para el curso del alumno
	 */
	private CursoAcademicoService cursoAcademicoService;

	@Autowired
	/**
	 * Servicio para el item evaluable falta de asistencia
	 */
	private RetrasoService retrasoService;

	@Autowired
	/**
	 * 
	 */
	private ProfesorService profesorService;

	@Autowired
	/**
	 * 
	 */
	private NotaPorEvaluacionService notaPorEvaluacionService;

	@Autowired
	/**
	 * 
	 */
	private EvaluacionService evaluacionService;

	@Autowired
	/**
	 * 
	 */
	private PadreMadreOTutorService tutorService;

	// Application context
	@Autowired
	/**
	 * 
	 */
	private ApplicationContext appContext;

	// Métodos CRUD

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Alumno create() {
		Alumno a = new Alumno();
		return a;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @return
	 */
	public Collection<Alumno> findAll() {
		List<Alumno> ite;
		ite = alumnoRepositorio.findAll();

		return ite;
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public Alumno findOne(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		return alumnoRepositorio.findOne(alumnoId);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void save(Alumno alumno) {
		Assert.notNull(alumno);
		alumnoRepositorio.save(alumno);
	}

	/**
	 * 
	 * @author David Romero Alcaide
	 * @param alumno
	 */
	public void delete(Alumno alumno) {
		Assert.notNull(alumno);
		Assert.isTrue(alumno.getId() > 0);
		alumnoRepositorio.delete(alumno);
	}

	// Otros métodos de negocio

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @param alumno
	 */
	public void establecerRetraso(Materia a, Alumno alumno) {
		Assert.notNull(a, "pasarLista.asignatura");
		Assert.notNull(alumno, "pasarLista.idAlumno");
		String except = "pasarLista.cursoAlum";
		Assert.isTrue(a.getCurso().getAlumnos().contains(alumno),
				except);
		Assert.isTrue(!(existeRetrasoEnAsignaturaParaHoy(a, alumno)),
				"pasarLista.yaExiste");

		Assert.isTrue(a.getProfesor().isIdentidadConfirmada(),
				except);

		/*
		 *  Es necesario que este creado el dia
		 */

		ItemEvaluable item = retrasoService.create();

		item.setFecha(new Date(System.currentTimeMillis()));
		item.setMateria(a);
		item.setCalificacion(0.0);
		item.setEvaluacion(evaluacionService.findByDate(new Date(System
				.currentTimeMillis())));
		retrasoService.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @return
	 * @param a
	 * @param asig
	 */
	private boolean existeRetrasoEnAsignaturaParaHoy(Materia asig, Alumno a) {
		boolean result = false;
		Assert.isTrue(asig.getProfesor().isIdentidadConfirmada());
		for (ItemEvaluable items : a.getItemsEvaluables()) {
			if (items instanceof Retraso && items.getMateria().equals(asig)) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Obtener los items evaluables de un alumno
	 * 
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<ItemEvaluable> obtenerItemsAlumno(Alumno alum) {
		return Lists.newArrayList(alumnoRepositorio.getAllItemsEvaluables(alum
				.getId()));
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public List<NotaPorEvaluacion> obtenerNotasPorEvaluacion(Alumno alum,Materia asignatura) {
		Map<Class<? extends ItemEvaluable>, Integer> criterios = asignatura.getCriteriosDeEvaluacion();
		Assert.isTrue(criterios.size() > 0);
		List<NotaPorEvaluacion> notas = Lists.newArrayList();
		List<List<Integer>> contadores = new ArrayList<List<Integer>>();
		List<List<Double>> medias = new ArrayList<List<Double>>();
		iniciarContadores(medias, contadores);
		calcularMediasDeNotas(alum, asignatura, contadores, medias);
		List<NotaPorEvaluacion> notasDelAlumnoEnAsignatura = notaPorEvaluacionService
				.getNotasPorEvaluacion(alum, asignatura);
		Assert.isTrue(notasDelAlumnoEnAsignatura.size() == 3);
		double nota = -1;
		
		nota = calcularNotaEvaluacion(medias.get(0), contadores.get(0), criterios);
		NotaPorEvaluacion nota1 = notasDelAlumnoEnAsignatura.get(0);
		nota1.setNotaFinal(nota);
		nota1.setAlumno(alum);
		nota1.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota1);

		this.save(alum);
		notas.add(nota1);

		nota = calcularNotaEvaluacion(medias.get(1), contadores.get(1), criterios);
		NotaPorEvaluacion nota2 = notasDelAlumnoEnAsignatura.get(1);
		nota2.setNotaFinal(nota);
		nota2.setAlumno(alum);
		nota2.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota2);

		this.save(alum);
		notas.add(nota2);
		nota = calcularNotaEvaluacion(medias.get(2), contadores.get(2), criterios);
		NotaPorEvaluacion nota3 = notasDelAlumnoEnAsignatura.get(2);
		nota3.setNotaFinal(nota);
		nota3.setAlumno(alum);
		nota3.setAsignatura(asignatura);
		notaPorEvaluacionService.save(nota3);

		this.save(alum);
		notas.add(nota3);
		return notas;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @param contadores
	 * @param medias
	 */
	private void calcularMediasDeNotas(Alumno alum, Materia
			asignatura,
			List<List<Integer>> contadores, List<List<Double>> medias) {
		for (ItemEvaluable item : obtenerItemsAlumnoAsignatura(alum, asignatura)) {
			calcularMediaItemsEvaluacion(medias, contadores, item, 0);
			calcularMediaItemsEvaluacion(medias, contadores, item, 1);
			calcularMediaItemsEvaluacion(medias, contadores, item, 2);
		}
	}

	/**
	 * Inicia los contadores y las sumas a 0
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 */
	private void iniciarContadores(List<List<Double>> medias,
			List<List<Integer>> contadores) {
		for (int i = 0; i < 3; i++) {
			medias.add(i, new ArrayList<Double>());
			contadores.add(i, new ArrayList<Integer>());
			for (int ii = 0; ii < 8; ii++) {
				medias.get(i).add(ii, 0.0);
				contadores.get(i).add(ii, 0);
			}
		}
	}

	/**
	 * Obtiene las medias de los items
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param item
	 * @param evaluacion
	 */
	private void calcularMediaItemsEvaluacion(List<List<Double>> medias,
			List<List<Integer>> contadores, ItemEvaluable item, int evaluacion) {
		Assert.notNull(item.getEvaluacion());
		String pack = "com.app.domain.model.types.itemsevaluables.";
		if (item.getEvaluacion().getIndicador() == (evaluacion + 1)) {
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Examen") == 0) {
				Double notaVieja = medias.get(evaluacion).get(4);
				medias.get(evaluacion).set(4,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(4);
				contadores.get(evaluacion).set(4, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Actividad") == 0) {
				Double notaVieja = medias.get(evaluacion).get(1);
				medias.get(evaluacion).set(1,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(1);
				contadores.get(evaluacion).set(1, contAntiguo + 1);
			}
			if (item.getClass()
					.getName()
					.compareTo(
							pack
									+ "Trabajo") == 0) {
				Double notaVieja = medias.get(evaluacion).get(7);
				medias.get(evaluacion).set(7,
						notaVieja + item.getCalificacion());
				int contAntiguo = contadores.get(evaluacion).get(7);
				contadores.get(evaluacion).set(7, contAntiguo + 1);
			}
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param asignatura
	 * @return
	 */
	public Collection<ItemEvaluable> obtenerItemsAlumnoAsignatura(Alumno alum,
			Asignatura asignatura) {
		Assert.notNull(asignatura);
		Assert.notNull(alum);
		return alumnoRepositorio.getAllItemsEvaluablesByAsignatura(
				alum.getId(), asignatura.getId());
	}

	/**
	 * Calcula la nota para una asignatura
	 * 
	 * @author David Romero Alcaide
	 * @param medias
	 * @param contadores
	 * @param criterios
	 * @param nota
	 * @return
	 */
	private double calcularNotaEvaluacion(List<Double> medias,
			List<Integer> contadores, Map<String, Integer> criterios) {
		double mediaExamen, mediaTrabajo, mediaActividad;
		if (contadores.get(4) == 0) {
			mediaExamen = 0.0;
		} else {
			mediaExamen = medias.get(4) / contadores.get(4);
		}
		if (contadores.get(7) == 0) {
			mediaTrabajo = 0.0;
		} else {
			mediaTrabajo = medias.get(7) / contadores.get(7);
		}
		if (contadores.get(1) == 0) {
			mediaActividad = 0.0;
		} else {
			mediaActividad = medias.get(1) / contadores.get(1);
		}
		double notaTotal = 0.0;

		Set<Entry<String, Integer>> conjuntoPares = criterios.entrySet();
		for (Entry<String, Integer> entry : conjuntoPares) {
			if (entry.getKey().equals("Examen")) {
				notaTotal += mediaExamen * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Trabajo")) {
				notaTotal += mediaTrabajo * entry.getValue() / 100;
			}

			if (entry.getKey().equals("Actividad")) {
				notaTotal += mediaActividad * entry.getValue() / 100;
			}
		}
		
		return notaTotal;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoId
	 * @return
	 */
	public List<PadreMadreOTutor> getTutores(int alumnoId) {
		Assert.isTrue(alumnoId > 0);
		Alumno alum = findOne(alumnoId);
		Assert.notNull(alum);
		return Lists.newArrayList(alum.getPadresMadresOTutores());
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void establecerItemEvaluacion(Date fecha, Alumno alumn,
			Materia asig, String tipoNota, int calificacion) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");

		ItemEvaluable item = servicio.create();
		if (calificacion < 5) {
			item.setTitulo(tipoNota + ", No trabaja");
		} else {
			item.setTitulo(tipoNota + ", Si trabaja");
		}

		item.setFecha(fecha);
		item.setMateria(asig);
		item.setCalificacion(calificacion);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param a
	 * @return
	 */
	public Collection<Profesor> getProfesores(Alumno alum) {
		Set<Profesor> profesores = Sets.newHashSet();
		return alum.getCursos().stream().filter(curso->{
			return curso.getCursoAcademico().equals(cursoAcademicoService.findActual());
		}).map(curso->{ return curso.getProfesor() }).collect(;)
		return profesores;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnosImportados
	 * @throws ParseException
	 */
	public void guardarAlumnosImportados(List<String[]> alumnosImportados)
			throws ParseException {
		for (String[] alumnoParseado : alumnosImportados) {
			Alumno a = this.create(alumnoParseado);

			for (Alumno temp : cursoService.getAlumnosEnCurso(a.getCurso()
					.getId())) {
				if (temp.getNombre().trim().compareTo(a.getNombre().trim()) == 0
						&& temp.getApellidos().trim()
								.compareTo(a.getApellidos().trim()) == 0
						&& new Date(temp.getFechaNacimiento().getTime())
								.equals(a.getFechaNacimiento())) {
					throw new IllegalArgumentException("El alumno "
							+ temp.getNombre() + temp.getApellidos()
							+ " ya está registrado en el sistema");
				}
			}
			alumnoRepositorio.save(a);
		}
	}

	/**
	 * @author David Romero Alcaide
	 * @param alumnoParseado
	 * @return
	 * @throws ParseException
	 */
	private Alumno create(String[] alumnoParseado) throws ParseException {
		Alumno a = create();
		a.setNombre(alumnoParseado[0].trim());
		a.setApellidos(alumnoParseado[1].trim());
		String curso = alumnoParseado[2].trim();
		int nivel = Integer.valueOf(curso.split(" ")[0]);
		String nivelE = curso.split(" ")[1];
		char iden = curso.split(" ")[2].charAt(0);
		Curso c = cursoService.find(nivel, nivelE, iden);
		Assert.notNull(c);
		Assert.isTrue(profesorService.getCursosImparteDocencia().contains(c));
		a.setCurso(c);
		SimpleDateFormat sp = new SimpleDateFormat("mm/dd/yyyy");
		a.setFechaNacimiento(sp.parse(alumnoParseado[3]));
		try {
			a.setPendiente(alumnoParseado[4].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setPendiente(" ");
		}
		try {
			a.setRepiteCurso(alumnoParseado[5].trim());
		} catch (ArrayIndexOutOfBoundsException e) {
			LOGGER.error(e.getMessage(),e);
			a.setRepiteCurso(" ");
		}
		return a;
	}

	/**
	 * @author David Romero Alcaide
	 * @param item
	 * @param alumn
	 * @param tipoNota
	 * @param calificacion
	 */
	public void crearItemEvaluacion(Date fecha, Alumno alumn, Asignatura asig,
			String tipoNota, String titulo) {
		com.app.applicationservices.services.Service servicio = (com.app.applicationservices.services.Service) appContext
				.getBean(tipoNota + "Service");
		ItemEvaluable item = servicio.create();
		item.setTitulo(titulo);
		item.setFecha(fecha);
		item.setAsignatura(asig);
		item.setCalificacion(0);
		item.setEvaluacion(evaluacionService.findByDate(fecha));
		servicio.save(item);
	}

	/**
	 * @author David Romero Alcaide
	 * @param nombre
	 * @param apellidos
	 * @param c
	 * @param fechaNacimiento
	 * @return
	 */
	public Alumno findAlumno(String nombre, String apellidos, Curso c,
			Date fechaNacimiento) {
		Alumno alumnoBuscado = null;
		PadreMadreOTutor tutor = tutorService.findPrincipal();
		Assert.notNull(tutor);
		Assert.isTrue(tutor.isIdentidadConfirmada());
		Collection<Alumno> primerFiltro = alumnoRepositorio
				.findByCursoYFechaNacimiento(c.getId(), fechaNacimiento);
		for (Alumno a : primerFiltro) {
			if (a.getApellidos().equals(apellidos)
					&& a.getApellidos().compareTo(apellidos) == 0
					&& a.getNombre().equals(nombre)
					&& a.getNombre().compareTo(nombre) == 0
					&& !a.getPadresMadresOTutores().contains(tutor)
					&& a.getPadresMadresOTutores().size() <= 2) {
				alumnoBuscado = a;
			}
		}
		return alumnoBuscado;
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @param tutor
	 */
	public void vincularConProfesor(Alumno alum, PadreMadreOTutor tutor) {
		Assert.notNull(tutor);
		Assert.isTrue(!alum.getPadresMadresOTutores().contains(tutor));
		alum.addPadreMadreOTutor(tutor);
		tutor.addTutorando(alum);
		save(alum);
		tutorService.save(tutor);
	}

	/**
	 * @author David Romero Alcaide
	 * @param alum
	 * @return
	 */
	public Collection<FaltaDeAsistencia> getFaltasAlumno(Alumno alum) {
		List<FaltaDeAsistencia> faltas = Lists.newArrayList();
		Collection<ItemEvaluable> items = alumnoRepositorio
				.getAllItemsEvaluables(alum.getId());
		for (ItemEvaluable item : items) {
			if (item instanceof FaltaDeAsistencia) {
				FaltaDeAsistencia falta = (FaltaDeAsistencia) item;
				faltas.add(falta);
			}
		}
		return faltas;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-04-18 00:12:57.015
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:57.015
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:57.015
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-04-18 00:12:57.015
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2015-04-18 00:12:57.015
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.nullStatus(MessageSend.java:519)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.checkNPE(MessageSend.java:361)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:94)
	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)
	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(ForeachStatement.java:125)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:124)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:737)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:261)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:932)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
